<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[So Terrible]]></title>
      <url>http://yoursite.com/2017/08/01/2017/8/%E7%9E%8E%E6%90%9E/</url>
      <content type="html"><![CDATA[<p>很久没有写了。尤其是技术文章，一个多月没写了。本来这篇文章应该早一个月前写出来的。一直想把这篇我文章写好点，所以一直在看，在研究相关的问题。但是迟迟拖到现在也没完成。非常的遗憾，平时琐碎的时间太多。有时候觉得自己弄懂了就行了何必再去写东西呢！写一篇高质量的文章非常耗时，从写Demo到一步一步分析。😔还是没能完成最终的想法。就当给自己一个教训！<br><a id="more"></a></p>
<h1 id="瞎倒腾"><a href="#瞎倒腾" class="headerlink" title="瞎倒腾"></a>瞎倒腾</h1><p>几大核心对象（Util）如下：</p>
<ol>
<li>GCDAsyncSocketPreBuffer：用于当socket有更多可用的数据请求的时候而不是被当前读请求使用。在这种情况下将会从socket中剔除所有数据来最小化系统调用。并且将其他尚未被读取的数据放如preBuffer中。再次从socket读取之前，会填满preBuffer，换句话说也就是大量的数据会被写入preBuffer。接下来通过一系列的一次或多次读取(后续的读取请求)排除preBuffer。之前为了实现这个目的，使用了ring Buffer，但是一个ringBuffer占用的存储是需要的两倍，实际上通常是需要两倍以上的大小，因为所有内容必须四舍五入到vm_page_size。因为preBuffer在写入之后总是完全耗尽，所以不需要完整ringBuffer。目前通过链表实现的</li>
<li>GCDAsyncReadPacket：用于对可读数据包装，可读包可以确定是否读到了某个长度、短刀了么讴歌分隔符，捉着读到了第一个可用的chunk数据</li>
<li>GCDAsyncWritePacket：用于对可写数据包装</li>
<li>GCDAsyncSpecialPacket：对在读写队列中终端的特殊指令包装</li>
<li>GCDAsyncSocket：最终向外部暴露的类，使用标准的代理模式。在所给的代理队列里面回调。允许设置最大并发，提供了简单的线程安全。</li>
<li>Class Utilities：常用工具方法<ul>
<li>根据域名得到ip地址数组：lookupHost:(NSString *)host port:(uint16_t)port error:</li>
<li>是否为ipv4、ipv6</li>
</ul>
</li>
</ol>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>连接最终调用如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (BOOL)connectToHost:(NSString *)inHost</div><div class="line">               onPort:(uint16_t)port</div><div class="line">         viaInterface:(NSString *)inInterface</div><div class="line">          withTimeout:(NSTimeInterval)timeout</div><div class="line">                error:(NSError **)errPtr</div></pre></td></tr></table></figure>
<p>各个参数的意思很清楚，这里说一下参数inInterface。代表的是网卡接口。常见的如下：</p>
<ul>
<li>en1（Wireless NIC）无线网卡</li>
<li>lo0（本机环路），</li>
<li>en0有线网卡 （Wired NIC）。</li>
<li><p>注意：<strong>MBP 上没有有线网卡，en0 即为无线网卡</strong> ，可通过 ifconfig 命令自行识别。</p>
<p>它的值可以是”en1” or “lo0”也可以是ip地址。并且可以包含一个端口，用冒号分开。如果interface有值，则后面会将本机的IPV4 IPV6的 address设置上。</p>
<p>将参数传递进来之后立即将参数copy了一份保证不被外部修改。然后发起同步的链接。</p>
</li>
</ul>
<h3 id="dispatch-queue-set-specific"><a href="#dispatch-queue-set-specific" class="headerlink" title="dispatch_queue_set_specific"></a>dispatch_queue_set_specific</h3><p> 因为连接过程是在特定的socket队列中完成，所以用了dispatch_queue_set_specific来实现。</p>
<p> dispatch_queue_set_specific的使用方法比较简单，只要理解它就是为某个队列打个标记，然后通过这个标记取出来。可以简单的把他理解为一个字典。</p>
<ul>
<li>打标记：<code>dispatch_queue_set_specific(socketQueue, IsOnSocketQueueOrTargetQueueKey, nonNullUnusedPointer, NULL);</code></li>
<li>根据标记取：<code>dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey)</code></li>
</ul>
<h3 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h3><p>连接过程的非常多。这里把整个过程简化了一下。</p>
<p><strong>从开始连接到最终连接，最终调用走到<code>int result = connect(socketFD, (const struct sockaddr *)[address bytes], (socklen_t)[address length]);</code></strong></p>
<p>注意一点连接的过程全部放在了自动释放池@autoreleasepool中。目的也是为了优化性能。</p>
<p>在开始连接之前做了一个预处理。里面做了几个重要的事情：</p>
<ol>
<li>参数检验：代理是否为空、当前队列是否为socket队列、当前状态是否已经连接、清空读写队列</li>
<li>状态更新：用flags |= kSocketStarted;方式更新状态标识为开始Socket连接</li>
<li>域名解析(ipv4、ipv6)：返回的是一个数组</li>
<li>开始去连接：在全局队列里面调用[strongSelf lookup:aStateIndex didSucceedWithAddress4:address4 address6:address6];</li>
</ol>
<p>开始连接的过程有如下几个函数：</p>
<ul>
<li><code>- (void)lookup:(int)aStateIndex didSucceedWithAddress4:(NSData *)address4 address6:(NSData *)address6</code><ul>
<li>根据ip配置过滤，是否禁用ip4/6，报错则关闭连接。</li>
</ul>
</li>
<li><code>- (BOOL)connectWithAddress4:(NSData *)address4 address6:(NSData *)address6 error:(NSError **)errPtr</code><ul>
<li>获取具体的ipv4、ipv6地址。根据配置确定socketFD的值，socketFD为最终连接数据。</li>
</ul>
</li>
<li><code>- (void)connectSocket:(int)socketFD address:(NSData *)address stateIndex:(int)aStateIndex</code><ul>
<li>最终调用connect方法，将上面得到socketFD进行连接。注意这个方法是个同步的，会阻塞线程。<h2 id="Source-Timer"><a href="#Source-Timer" class="headerlink" title="Source/Timer"></a>Source/Timer</h2>如果了解过runloop底层的同学就知道source这个东西。项目中一共定义了如下几种source</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dispatch_source_t accept4Source;</div><div class="line">	dispatch_source_t accept6Source;</div><div class="line">	dispatch_source_t acceptUNSource;</div><div class="line">    </div><div class="line">    //连接timer,GCD定时器</div><div class="line">	dispatch_source_t connectTimer;</div><div class="line">	dispatch_source_t readSource;</div><div class="line">	dispatch_source_t writeSource;</div><div class="line">	dispatch_source_t readTimer;</div><div class="line">	dispatch_source_t writeTimer;</div></pre></td></tr></table></figure>
<p>基本上分为三种，一种是用于监听连接的accept类型，一种是读写read、write，一种是定时器source。通过这几种source，达到监听网络连接、读写进度、定时器计时。</p>
<h3 id="连接-1"><a href="#连接-1" class="headerlink" title="连接"></a>连接</h3><p>通过代理来看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">    // 连接</div><div class="line">accept4Source = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, socket4FD, 0, socketQueue);</div><div class="line"></div><div class="line">int socketFD = socket4FD;</div><div class="line">dispatch_source_t acceptSource = accept4Source;</div><div class="line"></div><div class="line">__weak GCDAsyncSocket *weakSelf = self;</div><div class="line"></div><div class="line">         //事件句柄</div><div class="line">dispatch_source_set_event_handler(accept4Source, ^&#123; @autoreleasepool &#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic warning &quot;-Wimplicit-retain-self&quot;</div><div class="line">	</div><div class="line">	__strong GCDAsyncSocket *strongSelf = weakSelf;</div><div class="line">	if (strongSelf == nil) return_from_block;</div><div class="line">	</div><div class="line">	LogVerbose(@&quot;event4Block&quot;);</div><div class="line">	</div><div class="line">	unsigned long i = 0;</div><div class="line">             //拿到数据，连接数</div><div class="line">	unsigned long numPendingConnections = dispatch_source_get_data(acceptSource);</div><div class="line">	</div><div class="line">	LogVerbose(@&quot;numPendingConnections: %lu&quot;, numPendingConnections);</div><div class="line">	</div><div class="line">             //循环去接受这些socket的事件</div><div class="line">	while ([strongSelf doAccept:socketFD] &amp;&amp; (++i &lt; numPendingConnections));</div><div class="line">	</div><div class="line">#pragma clang diagnostic pop</div><div class="line">&#125;&#125;);</div><div class="line"></div><div class="line">//取消句柄</div><div class="line">dispatch_source_set_cancel_handler(accept4Source, ^&#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic warning &quot;-Wimplicit-retain-self&quot;</div><div class="line">	</div><div class="line">	#if !OS_OBJECT_USE_OBJC</div><div class="line">	LogVerbose(@&quot;dispatch_release(accept4Source)&quot;);</div><div class="line">	dispatch_release(acceptSource);</div><div class="line">	#endif</div><div class="line">	</div><div class="line">	LogVerbose(@&quot;close(socket4FD)&quot;);</div><div class="line">             //关闭socket</div><div class="line">	close(socketFD);</div><div class="line"></div><div class="line">#pragma clang diagnostic pop</div><div class="line">&#125;);</div><div class="line"></div><div class="line">LogVerbose(@&quot;dispatch_resume(accept4Source)&quot;);</div><div class="line">         //开启source</div><div class="line">dispatch_resume(accept4Source);</div></pre></td></tr></table></figure>
<p>一旦有网络连接连上就会调用dispatch_source_set_event_handler设置的block。当取消连接的时候就会走dispatch_source_set_cancel_handler的block。注意source不会自己启动，需要手动启动。一切的开始都是从这一步开始的。</p>
<h3 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h3><p>读和写逻辑上基本一样，同样是开始创建事件源，设置监听回调、设置取消回调，手动启动几个步骤。具体步骤可以看看下面的注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">//GCD source DISPATCH_SOURCE_TYPE_READ 会一直监视着 socketFD，直到有数据可读</div><div class="line">	readSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, socketFD, 0, socketQueue);</div><div class="line">    //_dispatch_source_type_write ：监视着 socketFD，直到写数据了</div><div class="line">	writeSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_WRITE, socketFD, 0, socketQueue);</div><div class="line">	</div><div class="line">	// Setup event handlers</div><div class="line">	</div><div class="line">	__weak GCDAsyncSocket *weakSelf = self;</div><div class="line">    </div><div class="line">#pragma mark readSource的回调</div><div class="line"></div><div class="line">	//GCD事件句柄  读，当socket中有数据流出现，就会触发这个句柄，全自动，不需要手动触发</div><div class="line">	dispatch_source_set_event_handler(readSource, ^&#123; @autoreleasepool &#123;</div><div class="line">	#pragma clang diagnostic push</div><div class="line">	#pragma clang diagnostic warning &quot;-Wimplicit-retain-self&quot;</div><div class="line">		</div><div class="line">		__strong GCDAsyncSocket *strongSelf = weakSelf;</div><div class="line">		if (strongSelf == nil) return_from_block;</div><div class="line">		</div><div class="line">		LogVerbose(@&quot;readEventBlock&quot;);</div><div class="line">		//从readSource中，获取到数据长度，</div><div class="line">		strongSelf-&gt;socketFDBytesAvailable = dispatch_source_get_data(strongSelf-&gt;readSource);</div><div class="line">		LogVerbose(@&quot;socketFDBytesAvailable: %lu&quot;, strongSelf-&gt;socketFDBytesAvailable);</div><div class="line">		</div><div class="line">        //如果长度大于0，开始读数据</div><div class="line">		if (strongSelf-&gt;socketFDBytesAvailable &gt; 0)</div><div class="line">			[strongSelf doReadData];</div><div class="line">		else</div><div class="line">            //因为触发了，但是却没有可读数据，说明读到当前包边界了。做边界处理</div><div class="line">			[strongSelf doReadEOF];</div><div class="line">		</div><div class="line">	#pragma clang diagnostic pop</div><div class="line">	&#125;&#125;);</div><div class="line">	</div><div class="line">    //写事件句柄</div><div class="line">	dispatch_source_set_event_handler(writeSource, ^&#123; @autoreleasepool &#123;</div><div class="line">	#pragma clang diagnostic push</div><div class="line">	#pragma clang diagnostic warning &quot;-Wimplicit-retain-self&quot;</div><div class="line">		</div><div class="line">		__strong GCDAsyncSocket *strongSelf = weakSelf;</div><div class="line">		if (strongSelf == nil) return_from_block;</div><div class="line">		</div><div class="line">		LogVerbose(@&quot;writeEventBlock&quot;);</div><div class="line">		//标记为可接受数据</div><div class="line">		strongSelf-&gt;flags |= kSocketCanAcceptBytes;</div><div class="line">        //开始写</div><div class="line">		[strongSelf doWriteData];</div><div class="line">		</div><div class="line">	#pragma clang diagnostic pop</div><div class="line">	&#125;&#125;);</div><div class="line">	</div><div class="line">	// Setup cancel handlers</div><div class="line">	</div><div class="line">	__block int socketFDRefCount = 2;</div><div class="line">	</div><div class="line">	#if !OS_OBJECT_USE_OBJC</div><div class="line">	dispatch_source_t theReadSource = readSource;</div><div class="line">	dispatch_source_t theWriteSource = writeSource;</div><div class="line">	#endif</div><div class="line">	</div><div class="line">    //读写取消的句柄</div><div class="line">	dispatch_source_set_cancel_handler(readSource, ^&#123;</div><div class="line">	#pragma clang diagnostic push</div><div class="line">	#pragma clang diagnostic warning &quot;-Wimplicit-retain-self&quot;</div><div class="line">		</div><div class="line">		LogVerbose(@&quot;readCancelBlock&quot;);</div><div class="line">		</div><div class="line">		#if !OS_OBJECT_USE_OBJC</div><div class="line">		LogVerbose(@&quot;dispatch_release(readSource)&quot;);</div><div class="line">		dispatch_release(theReadSource);</div><div class="line">		#endif</div><div class="line">		</div><div class="line">		if (--socketFDRefCount == 0)</div><div class="line">		&#123;</div><div class="line">			LogVerbose(@&quot;close(socketFD)&quot;);</div><div class="line">            //关闭socket</div><div class="line">			close(socketFD);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	#pragma clang diagnostic pop</div><div class="line">	&#125;);</div><div class="line">	</div><div class="line">	dispatch_source_set_cancel_handler(writeSource, ^&#123;</div><div class="line">	#pragma clang diagnostic push</div><div class="line">	#pragma clang diagnostic warning &quot;-Wimplicit-retain-self&quot;</div><div class="line">		</div><div class="line">		LogVerbose(@&quot;writeCancelBlock&quot;);</div><div class="line">		</div><div class="line">		#if !OS_OBJECT_USE_OBJC</div><div class="line">		LogVerbose(@&quot;dispatch_release(writeSource)&quot;);</div><div class="line">		dispatch_release(theWriteSource);</div><div class="line">		#endif</div><div class="line">		</div><div class="line">		if (--socketFDRefCount == 0)</div><div class="line">		&#123;</div><div class="line">			LogVerbose(@&quot;close(socketFD)&quot;);</div><div class="line">            //关闭socket</div><div class="line">			close(socketFD);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	#pragma clang diagnostic pop</div><div class="line">	&#125;);</div></pre></td></tr></table></figure>
<h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><p>计时器可以用NSTimer但是精度上没有source那么精确<br>这里以一个读超时计时器为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">//生成一个定时器source</div><div class="line">		readTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, socketQueue);</div><div class="line">		</div><div class="line">		__weak GCDAsyncSocket *weakSelf = self;</div><div class="line">		</div><div class="line">        //句柄</div><div class="line">		dispatch_source_set_event_handler(readTimer, ^&#123; @autoreleasepool &#123;</div><div class="line">		#pragma clang diagnostic push</div><div class="line">		#pragma clang diagnostic warning &quot;-Wimplicit-retain-self&quot;</div><div class="line">			</div><div class="line">			__strong GCDAsyncSocket *strongSelf = weakSelf;</div><div class="line">			if (strongSelf == nil) return_from_block;</div><div class="line">			</div><div class="line">            //执行超时操作</div><div class="line">			[strongSelf doReadTimeout];</div><div class="line">			</div><div class="line">		#pragma clang diagnostic pop</div><div class="line">		&#125;&#125;);</div><div class="line">		</div><div class="line">		#if !OS_OBJECT_USE_OBJC</div><div class="line">		dispatch_source_t theReadTimer = readTimer;</div><div class="line">        </div><div class="line">        //取消的句柄</div><div class="line">		dispatch_source_set_cancel_handler(readTimer, ^&#123;</div><div class="line">		#pragma clang diagnostic push</div><div class="line">		#pragma clang diagnostic warning &quot;-Wimplicit-retain-self&quot;</div><div class="line">			</div><div class="line">			LogVerbose(@&quot;dispatch_release(readTimer)&quot;);</div><div class="line">			dispatch_release(theReadTimer);</div><div class="line">			</div><div class="line">		#pragma clang diagnostic pop</div><div class="line">		&#125;);</div><div class="line">		#endif</div><div class="line">		</div><div class="line">        //定时器延时 timeout时间执行</div><div class="line">		dispatch_time_t tt = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(timeout * NSEC_PER_SEC));</div><div class="line">		//间隔为永远，即只执行一次</div><div class="line">		dispatch_source_set_timer(readTimer, tt, DISPATCH_TIME_FOREVER, 0);</div><div class="line">		dispatch_resume(readTimer);</div></pre></td></tr></table></figure>
<h3 id="source总结"><a href="#source总结" class="headerlink" title="source总结"></a>source总结</h3><p>通过上面的代码可以得出source的使用方式，而且整个GCDAsyncSocket都是建立在这个基础之上。设置各个source的回调处理方法。在事件到来的时候调用。如果手动取消则会调用cancle回调。基本上是照着葫芦画瓢的过程。</p>
<h2 id="读"><a href="#读" class="headerlink" title="读"></a>读</h2><p>读和写的过程和逻辑判断步骤基本相似的。</p>
<h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><p>往socket里面写数据调用<code>writeData: withTimeout: tag:</code></p>
<p>发送之前先将数据包装成GCDAsyncWritePacket对象。将packet加入到writeQueue当中，然后调用doWriteData方法。最终调用<code>ssize_t result = write(socketFD, buffer, (size_t)bytesToWrite);</code>中间经过一系列的条件判断。</p>
<ol>
<li><code>- (void)writeData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag</code></li>
<li><code>[self maybeDequeueWrite];</code> 一系列条件判断，比如TLS,SSL。超时设置</li>
<li><code>[self doWriteData];</code></li>
<li>Writing data directly over raw socket。</li>
</ol>
<p>注意ssize_t write(int fd, const void*buf,size_t nbytes);write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数.失败时返回-1. 并设置errno变量。</p>
<p>在写的时候可能一次写不完全，所以需要GCDAsyncWritePacket记录当前的已经上传多少。</p>
<blockquote>
<p>给自己截止的日期已经到了，但是还是没有整理出来。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> sourcecode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> think </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何阅读开源项目]]></title>
      <url>http://yoursite.com/2017/06/07/2017/6/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
      <content type="html"><![CDATA[<p>最近这段时间一直比较忙，相对于之前少了很多的学习时间。抽空看几篇源码分析的文章，大多数都是大同小异的思路，把英文翻译为中文而已。鉴于关于介绍如何阅读开源项目的文章比较稀少，常言道<strong>授人予鱼不如授人予渔</strong>。希望这篇文章能够给准备阅读三方源码的同学一些启示。<br><a id="more"></a></p>
<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p><img src="http://upload-images.jianshu.io/upload_images/664334-cd5448573458a33f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>在阅读源码之前最好明确一下阅读的目的，这样有助于阅读的深度和时间的控制。</strong>比如如果是为了解决项目中的bug，则可以阅读bug所涉及的部分；如果是为了提高自己的编码能力，学习设计技巧，则就需要更为深入的阅读。</p>
<p>因为阅读源码其实是一件非常辛苦的事情，尤其是分析一些大型开源项目的源码，如果毫无目的的阅读会浪费大量的时间。<strong>而且阅读源码也是一个长期的过程，不可能一天分析完Spring源码的分析</strong>，所以在分析源码之前一定要有一个明确的认识，不仅仅只是翻译英文注释，花大量的时间是在所难免的。</p>
<p>对笔者而言阅读源码的目的基本上可以分为如下几种：</p>
<ol>
<li>提高自己的编码能力，学习设计思想。</li>
<li>解决工作中所用第三方库遇到的bug。</li>
<li>借鉴开源代码，私有化别人的代码，完成工作需求。</li>
</ol>
<p>当然不排除某些大神，读源码纯粹是了找开源代码漏洞或者想改进该项目。毕竟这种牛逼的人是少数。当我们明确了阅读的目的就可以大致确定所需要花费的时间及精力了。</p>
<h1 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h1><p><img src="http://upload-images.jianshu.io/upload_images/664334-d759e5a41ea7b7ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>获取源码的地方太多了，最负有盛名的就是<a href="https://github.com/search?utf8=%E2%9C%93&amp;q=&amp;type=Repositories&amp;ref=searchresults" target="_blank" rel="external">GitHub</a>。除此之外还有<a href="https://sourceforge.net/" target="_blank" rel="external">sourceforge</a>，Google和Apple也有其开源项目下载地址，分别是<a href="https://opensource.google.com/" target="_blank" rel="external">Google OpenSource</a>、<a href="https://opensource.apple.com/" target="_blank" rel="external">Apple OpenSource</a>。国内有比较出名的有<a href="https://www.oschina.net/" target="_blank" rel="external">开源中国</a>，<a href="https://git.oschina.net/" target="_blank" rel="external">码云(开源中国代码托管平台)）</a>，<a href="https://coding.net/user" target="_blank" rel="external">Coding</a>。</p>
<p>整理一下：</p>
<ol>
<li><a href="https://github.com/search?utf8=%E2%9C%93&amp;q=&amp;type=Repositories&amp;ref=searchresults" target="_blank" rel="external">GitHub</a></li>
<li><a href="https://sourceforge.net/" target="_blank" rel="external">sourceforge</a></li>
<li><a href="https://opensource.google.com/" target="_blank" rel="external">Google OpenSource</a></li>
<li><a href="https://opensource.apple.com/" target="_blank" rel="external">Apple OpenSource</a></li>
<li><a href="https://www.oschina.net/" target="_blank" rel="external">开源中国</a></li>
<li><a href="https://git.oschina.net/" target="_blank" rel="external">码云(开源中国代码托管平台)）</a></li>
<li><a href="https://coding.net/user" target="_blank" rel="external">Coding</a></li>
</ol>
<p>在进行搜索的开源项目有很多搜索技巧，就拿GitHub举个例子。想高效的使用GitHub，一定要把<a href="https://github.com/search/advanced" target="_blank" rel="external"> advanced search</a>、<a href="https://help.github.com/articles/searching-github/#types-of-searches" target="_blank" rel="external">prefixes</a>看一下。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/664334-60bdc08289a60f5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>除了上面提到的开源项目下载地址，还有很多其他的地方可以获取到源码，这里就不多提了。</p>
<h1 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h1><p><img src="http://upload-images.jianshu.io/upload_images/664334-a4c7e4dca05a7220.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>阅读方法才是今天的重点，笔者一般是按照下面的步骤开始。</strong></p>
<ol>
<li>基本思想就是先对项目有个大致的了解。比如关键的类有哪些，各个文件夹之间的关系。</li>
<li>然后从最核心的API开始，先使用UML里的类图建立静态结构，分析出类与类之间的关系（继承，组合，实现，依赖，关联等等）。<strong>这一步是精读的必经之路，如果想要彻底理解，画UML图无意识最直接的方式。</strong></li>
<li>配合IDE工具分析核心流程，理解项目是如何工作的。</li>
<li>着重看项目中添加的注释，因为一般开源项目中的注释都非常重要。</li>
</ol>
<p>接下来分下面几个部分详细介绍。</p>
<ul>
<li>看：静态对代码进行分析，看相关资料，代码逻辑</li>
<li>跑：将项目在IDE里面跑起来，通过IDE调试参数，加Log等。</li>
<li>查：阅读过程中肯定会遇到不懂的，这时候需要通过搜索引擎来解决你的疑惑。</li>
</ul>
<h2 id="看"><a href="#看" class="headerlink" title="看"></a>看</h2><p>这个部分是非常基础但是重要的部分，主要完成对代码的基本感知。从静态的角度理解代码。</p>
<h3 id="现有资料"><a href="#现有资料" class="headerlink" title="现有资料"></a>现有资料</h3><p>在我们准备阅读某个开源项目之前，如果搜集了相关的资料的话，对我理解起来非常有帮助。也就是常说的<strong>站在巨人的肩膀上</strong>。</p>
<p>主要分为两种：</p>
<ol>
<li>项目官方文档比如Wiki</li>
<li>使用者分析的文档比如项目源码分析。</li>
</ol>
<p>GitHub上的开源项目大部分都有文档介绍，好一点的项目都会有对应的Wiki。<strong>除此之外开源项目的Issue也是我们需要关心的。往往这些Isuue对应到项目中都是核心部分，也就是我们非常值得关注的地方。</strong>如下图所示，一定要善用这些选项。因为这些都是前人踩过的坑，对于项目理解非常有用。<br><img src="http://upload-images.jianshu.io/upload_images/664334-573526a334ebaf12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>除了项目本身的文档外，还有一种形式的文档也需要我们注意。这类文档就是别人对这个项目写过的一些源码分析文章。这类文章已经对项目分析过一次了，先阅读完之后，会对我们自己去阅读源码起到一个理清思路，引路的作用。</p>
<p>但是有些大型的开源项目文档太多了，就官方说明文档就不可能一次看完，比如java中的Spring，看完文档也是不现实的。<strong>这个时候就应该把文档与代码调试结合在一起。效率会高不少。</strong>而且这类型的大型项目至少也得花一年半载才能弄清楚。</p>
<h3 id="代码内注释"><a href="#代码内注释" class="headerlink" title="代码内注释"></a>代码内注释</h3><p><strong>对于开源项目内注释一定，一定要仔细看看</strong>。在使用第三方库的时候，往往因为没有仔细阅读代码内注释而导致滥用方法。</p>
<p>如下图是iOS开源项目CocoaAsyncSocket一段代码内注释<br><img src="http://upload-images.jianshu.io/upload_images/664334-0faf30bc20d85d8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如果没有仔细看代码内注释，没有注意到必须设置代理和代理队列，遇到报错了根本不知道怎么发生的。</p>
<p>代码内注释是作者着重想传达给使用者的信息，所以切记切记，一定要仔细看代码内注释。但是好多人都误以为把注释看懂就是源码分析了，而且好多源码分析文章也是这样写的，把注释翻译一下，说明一下用途。</p>
<h2 id="跑"><a href="#跑" class="headerlink" title="跑"></a>跑</h2><p>这个过程是对代码的深入理解部分，通过改变函数参数，运行环境等。不同的语言用了不同的IDE，大部分IDE的作用都相差不多，都可以追溯堆栈，查看变量信息等。所以思路都是相同的。</p>
<h3 id="IDE调试"><a href="#IDE调试" class="headerlink" title="IDE调试"></a>IDE调试</h3><p>项目编译出来，运行加log，试着修改一些数据和代码，看看有什么变化。这是最为常用的方法。灵活使用IDE的debugger，而debugger最重要的功能是获取call stack。查看变量的变化情况，在你不知道有什么用的函数里加个断点，显示出来的call stack都能让你对系统有更清晰的认识。</p>
<p>关于IDE的调试使用常用的断点调试，变量跟中这些，这里就不多讲了。</p>
<h4 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h4><p>很多时候我们不知道某个变量或者某个变量具体的作用，<strong>那么这个时候就可以用到对CUD（Create,Update,Delete）思想</strong>。</p>
<p><strong>调试中的CUD具体来讲就是对源代码的类、函数、变量进行增加、修改、删除</strong>。如果一直停留在<code>看</code>源码的基础上很有可能不能透彻的理解，当我们掌握了代码设计规则，使用CUD方式可以加深理解，以及验证我们的猜想是否正确。</p>
<p><strong>特别注意，在实现项目中一定不要去修改第三方的源码，有时候可以通过修改第三方源码来达到暂时的目的，但是往往在后期维护，升级方面必将付出惨重的代价。这里指的CUD只适合在分析源码的时候。</strong></p>
<h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p><img src="http://upload-images.jianshu.io/upload_images/664334-a6d7c0f50fe4e75a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>在分析源码的过程中，肯定会遇到自己不懂的地方，对于这种问题，大部分靠自己现有的知识很有可能无法理解，这个时候就需要实在不懂就问了。Google、相关社区、GitHub Issue、Stackoverflow多搜多问。</p>
<p>查这个步骤应该是贯穿整个过程的，但是也得注意不是一遇到问题就上网查，而是应该在自己思考之后，得不到解答才去查。很多同学养成了一遇到问题就Google，百度，其实从长远来看不利于自己的提升。</p>
<h1 id="分析总结"><a href="#分析总结" class="headerlink" title="分析总结"></a>分析总结</h1><p>走完上面的步骤之后，基本上对一个项目源码掌握了。但是这个层次还是有点low。仅仅停留在理解的阶段，如果想做得更好就需要对项目的设计进行分析，看看有没有可以改进的地方，甚至完全试一试自己能不能针对某个模块改进一下。</p>
<p>这个阶段类似于<code>提升、创新</code>的程度，建立在见多识广的基础之上，对于阅读开源项目不多的同学还是非常有难度的。</p>
<h1 id="整理成文"><a href="#整理成文" class="headerlink" title="整理成文"></a>整理成文</h1><p>最后的阶段就是把自己分析的内容整理成为文档，分享出来。这也是提升自己能力的一个重要渠道，在写文章的时候，会强迫自己对那些不清楚的知识点加深理解。</p>
<p>文章内容应包括自己整理的UML图，核心类的实现，代码设计技巧，以及告知读者使用该第三方的时候需要注意的问题。</p>
<p>在写文章的时候需要注意，不要过多的延伸。毕竟一个点所涉及的知识网太大了，选择其中比较核心的几点阐述即可。</p>
<h1 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h1>]]></content>
      
        <categories>
            
            <category> base </category>
            
        </categories>
        
        
        <tags>
            
            <tag> think </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XCode多项目(xcodeproj)使用Cocoapod管理]]></title>
      <url>http://yoursite.com/2017/05/13/2017/5/XCode%E5%A4%9A%E9%A1%B9%E7%9B%AE(xcodeproj)%E4%BD%BF%E7%94%A8Cocoapod%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>最近比较忙，空闲的时候看的是关于算法方面的。关于算法自己的脑子不够用想写点东西，但是感觉还没有很熟练。所以先写点其他的。<br><a id="more"></a></p>
<h1 id="XCode多项目-xcodeproj-使用Cocoapod管理"><a href="#XCode多项目-xcodeproj-使用Cocoapod管理" class="headerlink" title="XCode多项目(xcodeproj)使用Cocoapod管理"></a>XCode多项目(xcodeproj)使用Cocoapod管理</h1><blockquote>
<p>最近在写demo的时候遇到这个问题。平时开发大都是一个workspace下面的一个xcodeproj开发。由于demo中有多个xcodeproj。而且这几个xcodeproj都需要用到cocoapod。这里顺便记录下解决的方法</p>
</blockquote>
<h2 id="更改podfile"><a href="#更改podfile" class="headerlink" title="更改podfile"></a>更改podfile</h2><p>首先工程的目录结构如下；<br><img src="http://upload-images.jianshu.io/upload_images/664334-25cd6f9d28ed2e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>之所以会出现这样的问题还是对podfile文件格式不熟悉。</p>
<p><strong>原来cocoapod允许我们指定workspace以及每个target的xcodeproj文件的路径。原理就是这样，在每个target下面添加对应的路径即可。</strong></p>
<p>总体来说就是这个样子</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Uncomment the next line to define a global platform for your project</span></div><div class="line"><span class="comment"># platform :ios, '9.0'</span></div><div class="line">workspace <span class="string">'SocketDemo.xcworkspace'</span></div><div class="line"></div><div class="line">target <span class="string">'SocketDemo'</span> <span class="keyword">do</span></div><div class="line">  <span class="comment"># Uncomment the next line if you're using Swift or would like to use dynamic frameworks</span></div><div class="line">  <span class="comment"># use_frameworks!</span></div><div class="line"></div><div class="line">  <span class="comment"># Pods for SocketDemo</span></div><div class="line">  xcodeproj <span class="string">'SocketDemo.xcodeproj'</span></div><div class="line">  <span class="comment"># 网络库</span></div><div class="line">  pod <span class="string">'CocoaAsyncSocket'</span>, <span class="string">'~&gt; 7.4.3’</span></div><div class="line"></div><div class="line">end</div><div class="line"></div><div class="line"></div><div class="line">target 'SocketServe<span class="string">' do</span></div><div class="line">    # Uncomment the next line if you're using Swift <span class="keyword">or</span> would like to use dynamic frameworks</div><div class="line">    <span class="comment"># use_frameworks!</span></div><div class="line">    </div><div class="line">    <span class="comment"># Pods for CocoaAstnSocketDemo</span></div><div class="line">    xcodeproj <span class="string">'SocketServe/SocketServe.xcodeproj'</span></div><div class="line">    <span class="comment"># 网络库</span></div><div class="line">    pod <span class="string">'CocoaAsyncSocket'</span>, <span class="string">'~&gt; 7.4.3’</span></div><div class="line">    </div><div class="line">end</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">target 'CocoaAstnSocketDemo<span class="string">' do</span></div><div class="line">  # Uncomment the next line if you're using Swift <span class="keyword">or</span> would like to use dynamic frameworks</div><div class="line">  <span class="comment"># use_frameworks!</span></div><div class="line"></div><div class="line">  <span class="comment"># Pods for CocoaAstnSocketDemo</span></div><div class="line">  xcodeproj <span class="string">'CocoaAstnSocketDemo/CocoaAstnSocketDemo.xcodeproj'</span></div><div class="line">  <span class="comment"># 网络库</span></div><div class="line">  pod <span class="string">'CocoaAsyncSocket'</span>, <span class="string">'~&gt; 7.4.3’</span></div><div class="line"></div><div class="line">end</div></pre></td></tr></table></figure>
<p>需要注意有一下几点。</p>
<ol>
<li>workspace必须填而且在所有target外面</li>
<li>每个target对应的xcodeproj写在每个target配置里面</li>
<li>如果没有指明xcodeproj和workspace的路径默认就会用根目录下面的<code>*.xcodeproj</code>、<code>*.workspace</code>为标</li>
</ol>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
            <category> base </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基础回顾之C编译过程及预处理器]]></title>
      <url>http://yoursite.com/2017/05/06/2017/5/%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%E4%B9%8BC%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%8F%8A%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>做技术，越做到后面越觉得基础、底层的才是越难得，也会越有技术含量的。最近做的项目有关音视频、图像处理，涉及到的都死c和c++相关的代码。遇到了问题才发现，c和c++才是通用大法。这两块没学好，那也只有玩一玩应用层、UI这些东西。抽空整理下。<br><a id="more"></a></p>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>如果需要弄清整个编译过程，那还得好好复习下编译原理。这里只是通过一个小例子讨论大致过程。</p>
<p>准备好一个helloworld的c文件。内容最好简单如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>编译命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ gcc helloworld.c // 编译</div><div class="line">$ ./a.out // 执行</div><div class="line">Hello World!</div></pre></td></tr></table></figure>
<p>gcc命令其实依次执行了四步操作：</p>
<ol>
<li><p>预处理(Preprocessing)</p>
<ul>
<li>预处理用于将所有的#include头文件以及宏定义替换成其真正的内容，预处理之后得到的仍然是文本文件，但文件体积会大很多。</li>
<li>命令: <code>gcc -E -I./ helloworld.c -o helloworld.i</code> 或者直接用<code>cpp helloworld.c -I./ -o helloworld.i</code></li>
<li>参数说明：<ul>
<li><code>-E</code>是让编译器在预处理之后就退出，不进行后续编译过程；</li>
<li><code>-I</code>指定头文件目录，这里指定的是我们自定义的头文件目录；</li>
<li><code>-o</code>指定输出文件名。</li>
</ul>
</li>
<li><p>经过预处理之后代码体积会大很多。如下是预处理之后的部分内容。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"># 1 "helloworld.c"</div><div class="line"># 1 "&lt;built-in&gt;" 1</div><div class="line"># 1 "&lt;built-in&gt;" 3</div><div class="line"># 330 "&lt;built-in&gt;" 3</div><div class="line"># 1 "&lt;command line&gt;" 1</div><div class="line"># 1 "&lt;built-in&gt;" 2</div><div class="line"># 1 "helloworld.c" 2</div><div class="line">typedef unsigned char __uint8_t;</div><div class="line">typedef short __int16_t;</div><div class="line">typedef unsigned short __uint16_t;</div><div class="line">typedef int __int32_t;</div><div class="line">typedef unsigned int __uint32_t;</div><div class="line">typedef long long __int64_t;</div><div class="line">typedef unsigned long long __uint64_t;</div><div class="line">typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;</div><div class="line">typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;</div><div class="line">typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;</div><div class="line">typedef unsigned long __darwin_pthread_key_t;</div><div class="line">typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;</div><div class="line">typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;</div><div class="line">FILE *fopen(const char * restrict __filename, const char * restrict __mode) __asm("_" "fopen" );</div><div class="line"></div><div class="line">int fprintf(FILE * restrict, const char * restrict, ...) __attribute__((__format__ (__printf__, 2, 3)));</div><div class="line">int fputc(int, FILE *);</div><div class="line">int fputs(const char * restrict, FILE * restrict) __asm("_" "fputs" );</div><div class="line">size_t fread(void * restrict __ptr, size_t __size, size_t __nitems, FILE * restrict __stream);</div><div class="line">FILE *freopen(const char * restrict, const char * restrict,</div><div class="line">                 FILE * restrict) __asm("_" "freopen" );</div><div class="line">int fscanf(FILE * restrict, const char * restrict, ...) __attribute__((__format__ (__scanf__, 2, 3)));</div><div class="line">int fseek(FILE *, long, int);</div><div class="line">int fsetpos(FILE *, const fpos_t *);</div><div class="line">long ftell(FILE *);</div><div class="line">size_t fwrite(const void * restrict __ptr, size_t __size, size_t __nitems, FILE * restrict __stream) __asm("_" "fwrite" );</div><div class="line">int getc(FILE *);</div><div class="line">int getchar(void);</div><div class="line">char *gets(char *);</div><div class="line">void perror(const char *);</div><div class="line">int printf(const char * restrict, ...) __attribute__((__format__ (__printf__, 1, 2)));</div><div class="line">int putc(int, FILE *);</div><div class="line">int putchar(int);</div><div class="line">int puts(const char *);</div><div class="line">int remove(const char *);</div><div class="line">int rename (const char *__old, const char *__new);</div><div class="line">void rewind(FILE *);</div><div class="line">int scanf(const char * restrict, ...) __attribute__((__format__ (__scanf__, 1, 2)));</div><div class="line">void setbuf(FILE * restrict, char * restrict);</div><div class="line">int setvbuf(FILE * restrict, char * restrict, int, size_t);</div><div class="line">int sprintf(char * restrict, const char * restrict, ...) __attribute__((__format__ (__printf__, 2, 3))) __attribute__((__availability__(swift, unavailable, message="Use snprintf instead.")));</div><div class="line">int sscanf(const char * restrict, const char * restrict, ...) __attribute__((__format__ (__scanf__, 2, 3)));</div><div class="line">FILE *tmpfile(void);</div><div class="line"></div><div class="line">__attribute__((__availability__(swift, unavailable, message="Use mkstemp(3) instead.")))</div><div class="line"></div><div class="line">__attribute__((deprecated("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tmpnam(3), it is highly recommended that you use mkstemp(3) instead.")))</div><div class="line">... 中间很多内容这里省略</div><div class="line"></div><div class="line">extern int __vsnprintf_chk (char * restrict, size_t, int, size_t,</div><div class="line">       const char * restrict, va_list);</div><div class="line"># 499 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.12.sdk/usr/include/stdio.h" 2 3 4</div><div class="line"># 2 "helloworld.c" 2</div><div class="line">int main()&#123;</div><div class="line">    printf("Hello World!\n");</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>编译(Compilation), </p>
<ul>
<li><strong>这里的编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理之后的程序转换成特定汇编代码(assembly code)的过程。</strong></li>
<li>命令:gcc -S -I./ helloworld.c -o helloworld.s</li>
<li>参数:<code>-S</code>为了编译之后停止。后面的两个参数含义和预处理的时候一样</li>
<li><p>经过编译之后的内容如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">	.section	__TEXT,__text,regular,pure_instructions</div><div class="line">	.macosx_version_min 10, 12</div><div class="line">	.globl	_main</div><div class="line">	.p2align	4, 0x90</div><div class="line">_main:                                  ## @main</div><div class="line">	.cfi_startproc</div><div class="line">## BB#0:</div><div class="line">	pushq	%rbp</div><div class="line">Ltmp0:</div><div class="line">	.cfi_def_cfa_offset 16</div><div class="line">Ltmp1:</div><div class="line">	.cfi_offset %rbp, -16</div><div class="line">	movq	%rsp, %rbp</div><div class="line">Ltmp2:</div><div class="line">	.cfi_def_cfa_register %rbp</div><div class="line">	subq	$16, %rsp</div><div class="line">	leaq	L_.str(%rip), %rdi</div><div class="line">	movl	$0, -4(%rbp)</div><div class="line">	movb	$0, %al</div><div class="line">	callq	_printf</div><div class="line">	xorl	%ecx, %ecx</div><div class="line">	movl	%eax, -8(%rbp)          ## 4-byte Spill</div><div class="line">	movl	%ecx, %eax</div><div class="line">	addq	$16, %rsp</div><div class="line">	popq	%rbp</div><div class="line">	retq</div><div class="line">	.cfi_endproc</div><div class="line"></div><div class="line">	.section	__TEXT,__cstring,cstring_literals</div><div class="line">L_.str:                                 ## @.str</div><div class="line">	.asciz	&quot;Hello World!\n&quot;</div><div class="line"></div><div class="line"></div><div class="line">.subsections_via_symbols</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>汇编(Assemble), </p>
<ul>
<li>汇编过程将上一步的汇编代码转换成机器码(machine code)，这一步产生的文件叫做目标文件，是二进制格式。如果有多个文件需要<strong>为每一个源文件产生一个目标文件。</strong></li>
<li>命令:as helloworld.s -o helloworld.o 或者 gcc -c helloworld.s -o helloworld.o</li>
</ul>
</li>
<li>链接(Linking)。<ul>
<li>链接过程将多个目标文以及所需的库文件(.so等)链接成最终的可执行文件(executable file)。</li>
<li>命令:ld -o helloworld.out helloworld.o <code>**.o</code> <code>**.o</code>。格式其实就是 <code>ld(选项)(参数)</code>参数就是需要连接的目标文件。由于这里没有生成其他目标文件，所以这段不会连接成功的。具体的命令可以看这里<a href="http://man.linuxde.net/ld" target="_blank" rel="external">ld命令</a></li>
</ul>
</li>
</ol>
<p>走完上面的步骤可以得到如下几个文件。<br><img src="http://upload-images.jianshu.io/upload_images/664334-efe31056eaf23961.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>其实我们平时写代码的到得到可执行文件的整个过程可以用下图来概括。<br><img src="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/images/C_DevelopmentProcesses.png" alt=""></p>
<h1 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h1><p>上面把基本的编译过程讲完了，现在就开始进入今天的正题。</p>
<h2 id="预处理前的操作"><a href="#预处理前的操作" class="headerlink" title="预处理前的操作"></a>预处理前的操作</h2><p>再进行预处理前，编译器会对源代码记性一些翻译过程。其中有几点需要知道:</p>
<ul>
<li>源代码中的资费映射到元字符集。使得C外观更加国际化</li>
<li>预处理表达式的长度为一逻辑行。</li>
<li><p>查找反斜杠后紧跟换行符的实例并删除。也即是预处理会删除反斜杠和换行符的组合。</p>
<ul>
<li><p>类似</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">printf</span>(<span class="string">"Hello, \</span></div><div class="line">               World!\n");</div></pre></td></tr></table></figure>
<p>  两行物理行变为一行<code>printf(&quot;Hello,World!\n&quot;);</code>经过测试在Xcode中会上面的形式会比项目多很多空格。</p>
<ul>
<li><strong>其实这就是为什么我们能够用宏定义定义函数的原理。</strong></li>
<li>文本划分为预处理语言符号、空白字符及注释序列。<strong>注意编译器会有空格代替注释</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h3><p>所有预处理指令都是以<code>#</code>开头。关于<code>#define</code>和<code>const</code>定义常量的区别也是需要值得注意的地方。<code>#define</code>做的是暴力替换，而<code>const</code>是针对性的。</p>
<h4 id="语言符号及字符型符号"><a href="#语言符号及字符型符号" class="headerlink" title="语言符号及字符型符号"></a>语言符号及字符型符号</h4><ul>
<li>字符型符号:额外的空格当成替换文本的一部分,空格也是主体的一部分。</li>
<li>语言符号:空格只是分隔主体的符号。</li>
</ul>
<p>例子<code>#define TEST 4  *  8</code></p>
<ul>
<li>字符型符号将TEST替换为<code>4  *  8</code></li>
<li>语言符号将TEST替换为<code>4 * 8</code></li>
</ul>
<p><strong>C编译器把宏主体当成的是字符型符号</strong></p>
<p><strong>判断宏定义想不相同通过语言定义符号来确定。比如#define TEST 4<em>8和上面的就不是相同的宏定义因为它只有一个语言符号4`</em>`8。上面有三个分别是4、空格、8</strong></p>
<h3 id="define中使用参数"><a href="#define中使用参数" class="headerlink" title="define中使用参数"></a>define中使用参数</h3><p>使用参数很简单，就是<code>#define TEST(X) X*X</code>。规则如下：<br><img src="http://upload-images.jianshu.io/upload_images/664334-61ab9dcfa2b0079a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>特别需要注意的是宏参数和函数参数的区别，宏参数是进行严格的特换。这如果使用不懂就会出现非常严重的错误。</strong></p>
<h4 id="使用-参数：宏参数创建字符串"><a href="#使用-参数：宏参数创建字符串" class="headerlink" title="使用#参数：宏参数创建字符串"></a>使用<code>#</code>参数：宏参数创建字符串</h4><table>
<thead>
<tr>
<th>宏定义</th>
<th>调用</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>#define TESTPF(x) printf(&quot;test &quot;#x&quot; * &quot;#x&quot;=%d\n&quot;,(x)*(x));</code></td>
<td><code>TESTPF(5 + 5)</code></td>
<td><code>test 5 + 5 * 5 + 5=100</code></td>
</tr>
<tr>
<td><code>#define TESTPF(x) printf(&quot;test x * x=%d\n&quot;,(x)*(x));</code></td>
<td><code>TESTPF(5 + 5);</code></td>
<td><code>test x * x=100</code></td>
</tr>
</tbody>
</table>
<p>可以看到<code>#</code>参数的作用就是把字符串中的x也进行了替换。</p>
<h4 id="使用-参数：预处理粘合剂"><a href="#使用-参数：预处理粘合剂" class="headerlink" title="使用##参数：预处理粘合剂"></a>使用<code>##</code>参数：预处理粘合剂</h4><p><code>##</code>作用是把两个语言符号组合为单个语言符号。<br>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> XNAME(n) x##n</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_XN(n) printf(<span class="meta-string">"x"</span>#n<span class="meta-string">" = %d \n"</span>);</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">XNAME</span><span class="params">(<span class="number">1</span>)</span> </span>= <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">XNAME</span><span class="params">(<span class="number">2</span>)</span> </span>= <span class="number">2</span>;</div><div class="line">PRINT_XN(<span class="number">1</span>);</div><div class="line">PRINT_XN(<span class="number">2</span>);</div><div class="line"></div><div class="line">结果：</div><div class="line">x1 = <span class="number">1606416096</span> </div><div class="line">x2 = <span class="number">4352</span></div></pre></td></tr></table></figure>
<h4 id="和-VA-ARGS-可变宏"><a href="#和-VA-ARGS-可变宏" class="headerlink" title="...和__VA_ARGS__:可变宏"></a><code>...</code>和<code>__VA_ARGS__</code>:可变宏</h4><p>这个其实在iOS开发中还是用得挺多的。</p>
<p>例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PR(...) printf(__VA_ARGS__)</span></div><div class="line"></div><div class="line">PR(<span class="string">"DD"</span>);</div><div class="line">PR(<span class="string">"D=%d,F=%d\n"</span>,<span class="number">12</span>,<span class="number">22</span>);</div><div class="line"></div><div class="line">结果：</div><div class="line">DDD=<span class="number">12</span>,F=<span class="number">22</span></div></pre></td></tr></table></figure>
<p><strong>特别注意。省略号必须在最后一个参数位置。根据这个道理，有些同学可能就能联想到某些语言可变参数的位置为什么一定要在最后把。比如python</strong></p>
<h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>预处理器发现<code>#include</code>指令后，会寻找跟在后面的文件，把这个文件中的内容包含到当前文件中。<br><img src="http://upload-images.jianshu.io/upload_images/664334-bc5310a01554942b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>OC中有.h和.m文件，这和C里面的.h和.c是同一个道理。所以这里就不多说了。具体看图。<br><img src="http://upload-images.jianshu.io/upload_images/664334-eccfc5b06d18db96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="其他预处理指令"><a href="#其他预处理指令" class="headerlink" title="其他预处理指令"></a>其他预处理指令</h3><ul>
<li><code>#undef</code>取消已定义的宏</li>
<li><code>#if</code>如果给定条件为真，则编译下面代码</li>
<li><code>#elif</code>如果前面的#if给定条件不为真，当前条件为真，则编译下面代码</li>
<li><code>#endif</code>结束一个<code>#if……#else</code>条件编译块</li>
<li><code>#ifdef</code>如果宏已经定义，则编译下面代码</li>
<li><code>#ifndef</code>如果宏没有定义，则编译下面代码</li>
<li><code>#pragma</code>指令没有正式的定义。编译器可以自定义其用途。典型的用法是禁止或允许某些烦人的警告信息。</li>
</ul>
<p>上面这些预处理指令，用得比较频繁。大家应该不陌生。还多一些平时用得不多的。</p>
<ul>
<li><code>#line</code>指令可以改变编译器用来指出警告和错误信息的文件号和行号。</li>
<li><code>#error</code>停止编译并显示错误信息</li>
</ul>
<h4 id="预处理宏"><a href="#预处理宏" class="headerlink" title="预处理宏"></a>预处理宏</h4><p>C标准制定的一些预处理宏。<br><img src="http://upload-images.jianshu.io/upload_images/664334-9cfdabf2edcdb231.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>额外补充一个<code>__func__</code>预定义标识符。这个是C99标准提供的。用于标识当前函数。</p>
<p><strong>上面这些预处理宏经常用于打印一些日志信息。</strong></p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/c0_Introduction.html" target="_blank" rel="external">C programming Tutorial Introduction to C Programming (for Novices &amp; First-Time Programmers)</a><br><a href="http://www.cnblogs.com/zi-xing/p/4550246.html" target="_blank" rel="external">C/C++预处理指令#define,#ifdef,#ifndef,#endif…</a></p>
]]></content>
      
        <categories>
            
            <category> language </category>
            
            <category> base </category>
            
        </categories>
        
        
        <tags>
            
            <tag> recover </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基础回顾之存储类、链接与内存管理]]></title>
      <url>http://yoursite.com/2017/04/30/2017/4/%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%E4%B9%8B%E5%AD%98%E5%82%A8%E7%B1%BB%E3%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>做技术，越做到后面越觉得基础、底层的才是越难得，也会越有技术含量的。最近做的项目有关音视频、图像处理，涉及到的都死c和c++相关的代码。遇到了问题才发现，c和c++才是通用大法。这两块没学好，那也只有玩一玩应用层、UI这些东西。抽空整理下。</p>
<a id="more"></a>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>四种：</p>
<ul>
<li>多个文件共享的变量</li>
<li>特定文件每个函数共享的变量</li>
<li>某个函数特有的变量</li>
<li>某个函数一个代码块的变量</li>
</ul>
<p>一个C变量的作用域可以是代码块作用域，函数作用域，文件作用域，基本概念就不说了。</p>
<p>需要注意的几点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, i);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里<code>i</code>的作用域是整个for循环。</p>
<p>一个所有函数之外定义的变量就是文件作用域。整个文件可以访问该变量。也叫全局作用域</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CTest.h"</span></span></div><div class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, i);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, a);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">    a = <span class="number">6</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, a);</div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li>外部链接：多个文件使用</li>
<li>内部链接：当前文件使用</li>
<li>空连接：函数代码块使用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">4</span>; <span class="comment">// 外部链接</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">5</span>; <span class="comment">// 内部链接、文件私有</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="存储时期-变量在内存中生存的时间"><a href="#存储时期-变量在内存中生存的时间" class="headerlink" title="存储时期(变量在内存中生存的时间)"></a>存储时期(变量在内存中生存的时间)</h2><ul>
<li>静态存储：程序执行期间一直存储，<strong>文件作用域（内部和外部）的变量具有静态存储时期</strong>。文件作用域中特别注意用static表明链接类型而并非存储时期。一个使用了static生命的文件作用域变量表示这个变量具有内部作用域。</li>
<li>自动存储：代码块作用域的变量。</li>
</ul>
<p>5种存储类：自动，寄存器，代码作用域静态，外部静态，内部静态。下面这种表总结了上面的多种情况。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/664334-a707c14717537c95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>重点说明一下寄存器变量：寄存处变量是存储在CPU的寄存器中，比一般的内存要快很多。但是有一个问题就是寄存器变量的地址是无法获取的。</p>
</blockquote>
<p>把变量定义下所有函数之外，就创建了一个外部变量，为了使程序清晰，可以在使用使用外部变量的函数中通过extern来再次声明。如果变量在别的文件定义，使用extern来声明就是必须的。<strong>这里想一想OC中的写第三方库的时候，为了让其他模块能够访问某个变量就是通过这种方式来达到目的的。</strong></p>
<p>比如YYWebImageSetter中。<br>.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extern NSString *const _YYWebImageFadeAnimationKey;</div><div class="line">extern const NSTimeInterval _YYWebImageFadeTime;</div><div class="line">extern const NSTimeInterval _YYWebImageProgressiveFadeTime;</div></pre></td></tr></table></figure>
<p>.m</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *const _YYWebImageFadeAnimationKey = @&quot;YYWebImageFade&quot;;</div><div class="line">const NSTimeInterval _YYWebImageFadeTime = 0.2;</div><div class="line">const NSTimeInterval _YYWebImageProgressiveFadeTime = 0.4;</div></pre></td></tr></table></figure>
<p>函数也是具有存储类。<strong>函数默认是外部的，可以被其他文件中的函数调用，静态函数只可以在定义它的文件中使用（用static）</strong></p>
<blockquote>
<p>使用static可以防止名字的冲突，为文件定义一个私有的变量或者函数。<strong>想想平时我们在定义常量的时候，有时候会出现冲突，OC中用static解决的。应该有些同学有印象的。</strong></p>
</blockquote>
<h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>系统自动分配内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">float</span> x;</div><div class="line"><span class="keyword">char</span> hello = <span class="string">"hello world"</span>;</div></pre></td></tr></table></figure>
<p>系统将会预留出存储float或字符串的足够内存空间。也可以指定预留多少内存空间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> plates[<span class="number">100</span>];</div></pre></td></tr></table></figure>
<p>声明了100个内存位置，每个位置可以存储一个int值。这里的plate和上面的x、hello变量可以理解为内存的标识符。所以我们可以用x、hello来标识、获取这些内存数据。</p>
<h3 id="malloc-amp-amp-free-amp-amp-calloc"><a href="#malloc-amp-amp-free-amp-amp-calloc" class="headerlink" title="malloc&amp;&amp;free&amp;&amp;calloc"></a>malloc&amp;&amp;free&amp;&amp;calloc</h3><p>用于动态开辟内存。函数<code>void* malloc( size_t size );</code></p>
<p>函数说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Allocates size bytes of uninitialized storage.</div><div class="line">If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type.</div><div class="line">If size is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage, but has to be passed to free).</div><div class="line"></div><div class="line">malloc is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.</div><div class="line">A previous call to free or realloc that deallocates a region of memory synchronizes-with a call to malloc that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by malloc. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</div></pre></td></tr></table></figure>
<p>传入所需要的内存字节数，然后malloc找到内存中一个大小适合的快，内存是匿名的，<strong>不像上面可以用定义float x;x用于标识。不过返回的是一个开辟内存的第一个字节的地址。虽然没有为它指定名字，但是我们可以通过指针来接受返回的值来访问那块内存。</strong></p>
<p>因为char代表一个字节，所以经常将malloc定义为指向char的指针类型。但是后来又了新的类型——————通用型指针（void <code>*</code>）。这样就可以返回其他类型的了。特别注意<strong>如果malloc找不到所需的空间，就会返回空指针。比如传入一个负数就会返回NULl</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">double *dbl;</div><div class="line">dbl = malloc(30 * sizeof(double));</div></pre></td></tr></table></figure>
<p>请求30个double类型值的空间，并把dbl指向该空间的所在的起始位置。然后就可以使用数组那样使用它。<strong>简单来讲可以dbl[0],dbl[1]访问</strong></p>
<p>开辟了内存，必定要释放内存。用free释放内存。对应到OC就是那句内存管理的至理名言<strong>谁开辟、谁释放（alloc、release）</strong></p>
<p>一次malloc，应该调用一次free。free的参数是malloc返回的地址，释放掉先前分配的内存。不能使用free来释放通过其他形式分配的内存，比如声明一个数组。</p>
<h3 id="例子强调一下free的重要性"><a href="#例子强调一下free的重要性" class="headerlink" title="例子强调一下free的重要性"></a>例子强调一下free的重要性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void memoryTest() &#123;</div><div class="line">    double array[2000];</div><div class="line">    for (int i = 0; i&lt; 1000; i++) &#123;</div><div class="line">        testCopy(array, 2000);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">void testCopy(double arr[], int count) &#123;</div><div class="line">    double *temp = (double *)malloc(count * sizeof(double));</div><div class="line">    </div><div class="line">    // No free</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一次调用testCopy,创建指针temp,并使用malloc开辟了2000 <em> 16，一个32000个字节。当函数终止，temp作为自动变量被销毁，<em>*但是它指向的32000个字节的内存仍然存在，并且无法访问这些内存，因为地址不见了（temp销毁），由于没有调用free,那么就不可以再次使用这些内存。</em></em></p>
<p>第二次调用testCopy，又创建一个temp,但是第一次的32000字节的块已经不能再用了。所以malloc不得不再去开辟一块新的内存地址。当函数终止，这块内存同样没有调用free,创建的内存同样不能被访问。</p>
<blockquote>
<p>循环1000次，就是32000000个字节。已经有3200万字节在内存中中不能使用。<strong>这就是在做iOS开发中MRC时代经常遇到的内存泄漏。</strong></p>
</blockquote>
<p>为了说明问题，这里我用xcode测试了一下，把循环次数改为了100000000。</p>
<ul>
<li><p>没有加free之前。<br><img src="http://upload-images.jianshu.io/upload_images/664334-3af8bb29b5425122.gif?imageMogr2/auto-orient/strip" alt=""></p>
</li>
<li><p>加free之后。<br><img src="http://upload-images.jianshu.io/upload_images/664334-04e8d9cb332347d7.gif?imageMogr2/auto-orient/strip" alt=""></p>
</li>
</ul>
<p>对比上面很明显能看到两者的区别。</p>
<p>calloc与malloc最大的区别是calloc会把开辟的全部位置为0。使用方式和malloc类似，同样需要用free释放内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> *test;</div><div class="line">test = (<span class="keyword">long</span> *)<span class="built_in">calloc</span>(<span class="number">100</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</div></pre></td></tr></table></figure>
<p>开辟了可以容乃100个long类型的内存空间。</p>
<h2 id="常见的限定词"><a href="#常见的限定词" class="headerlink" title="常见的限定词"></a>常见的限定词</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>普通类型前，标识这个值不可变。而用在指针的时候情况就分多种了</p>
<p>因为指针存在，指针不可变还是指向的值不可变。</p>
<ul>
<li><code>const float *pf</code>（等同于<code>float const * pf</code>）:表示pf指向一个常量浮点型数值。<strong>但是pf本身的值可以改变。比如它可以指向另一个const值</strong></li>
<li><code>float * const pt</code>:表示pt是一个常量指针，他总是指向同一个地址，但是地址里面的内容可以改变。</li>
<li><code>const float * const pfc</code>:表示pfc是个常量指针，而且指向的地址内容也不能变。</li>
</ul>
<p><strong>记忆方式，const位于<code>*</code>左边代表指向的值不可变，位于<code>*</code>右边指针不可变</strong></p>
]]></content>
      
        <categories>
            
            <category> language </category>
            
            <category> base </category>
            
        </categories>
        
        
        <tags>
            
            <tag> recover </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dlib系列之在iOS中提取人脸特征点（第一篇）]]></title>
      <url>http://yoursite.com/2017/04/23/2017/4/Dlib%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9C%A8iOS%E4%B8%AD%E6%8F%90%E5%8F%96%E4%BA%BA%E8%84%B8%E7%89%B9%E5%BE%81%E7%82%B9%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AF%87%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>最近因为工作需要，在研究人脸识别，图像处理这块，这里简单记录一下。今天主要讲讲前期的准备工作，比如由C++制作OC的静态库。<br><a id="more"></a></p>
<h2 id="什么是dlib"><a href="#什么是dlib" class="headerlink" title="什么是dlib"></a>什么是dlib</h2><p><img src="http://dlib.net/dlib-logo.png" alt=""><br>摘自官网：</p>
<blockquote>
<p>Dlib is a modern C++ toolkit containing machine learning algorithms and tools for creating complex software in C++ to solve real world problems. It is used in both industry and academia in a wide range of domains including robotics, embedded devices, mobile phones, and large high performance computing environments. Dlib’s open source licensing allows you to use it in any application, free of charge.</p>
</blockquote>
<p>简单来讲Dlib是一套包含机器学习算法的C++工具集，用来解决现实生活的问题。最为重要的就是free of charge免费。</p>
<p>这个C++工具集包含了很多牛逼的特性：</p>
<ul>
<li>机器学习算法</li>
<li>数值算法</li>
<li>图像模型接口算法</li>
<li><strong>图片处理</strong><ul>
<li>高质量的人脸检测。<strong>这个部分是今天我们要用到的</strong></li>
</ul>
</li>
<li>线程操作</li>
<li>网络操作</li>
<li>…..</li>
</ul>
<p>一句话，反正这个库就是牛逼。</p>
<p><a href="http://dlib.net/" target="_blank" rel="external">官网文档</a><br><a href="https://github.com/davisking/dlib" target="_blank" rel="external">GitHub地址</a></p>
<h2 id="打包成静态库"><a href="#打包成静态库" class="headerlink" title="打包成静态库"></a>打包成静态库</h2><p>由于dlib是用c++写的，虽然xcode知识Swift、OC、C、C++混编，但是对于这种三房库最好打成静态库。</p>
<p>接下来就大致介绍一下如何完成这个步骤。</p>
<ul>
<li><p>前提条件</p>
<ol>
<li>X11(这个之前的mac是包含了的，但是现在需要自己下载安装)下载地址<a href="https://www.xquartz.org/" target="_blank" rel="external">X11</a>。相关的介绍可以看看这里<a href="https://support.apple.com/en-us/HT201341" target="_blank" rel="external">介绍</a></li>
<li>Xcode</li>
<li>cmake，如何之前玩过c或者c++这个应该安装过了。如果没安装过可以通过homebrew安装</li>
</ol>
</li>
<li><p>步骤</p>
<ol>
<li>将项目dlib clone 到本地。项目地址<code>https://github.com/davisking/dlib.git</code></li>
<li>在终端里面打开刚才clone下来的项目里面的examples目录。<br> <img src="http://upload-images.jianshu.io/upload_images/664334-aeb8b4d7799825ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>终端执行<code>mkdir build</code></li>
<li>终端执行<code>cd build</code></li>
<li>终端执行<code>cmake -G Xcode ..</code></li>
<li><p>终端执行<code>cmake --build . --config Release</code> <strong>这一步等的时间比较长，耐心一点</strong></p>
<p>如果没有出现异常，最后会出现<br><img src="http://upload-images.jianshu.io/upload_images/664334-5c9a313e90678b95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">这就说明成功了。</p>
</li>
</ol>
</li>
</ul>
<p>这一串命令最终会产生一个<code>dlib_build</code>目录，里面就是编译这个库的xcode项目。在这个项目里面可以根据你的需要设置这个SDK支持的架构和支持的平台（iOS、Mac）。</p>
<p>特别注意，需要额外添加一些编译标识和dlib依赖的三方库。<strong>可以直接根据examples.xcproject项目来查看具体的设置</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/664334-676f7df31ab560b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>通过上面的方式就制作好了一个包含dlib的静态库。</p>
<p>下面是生产.a的目录<br><img src="http://upload-images.jianshu.io/upload_images/664334-d06f9ffd05e2368e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>查看.a支持的架构可以通过<code>lipo -info xxx.a</code>查看。比如我这里就是<br><img src="media/14929190666528/14929242438453.jpg" alt=""></p>
<h2 id="将静态库添加到项目中去"><a href="#将静态库添加到项目中去" class="headerlink" title="将静态库添加到项目中去"></a>将静态库添加到项目中去</h2><p>刚才制作好了libdlib.a。接下来就是去使用它。</p>
<ol>
<li><p>将刚才生产的.a和dlib的库文件拖到同一个文件夹。<br><img src="http://upload-images.jianshu.io/upload_images/664334-05f88ee04ea3e683.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>将这两个加到项目实体中。<br><img src="http://upload-images.jianshu.io/upload_images/664334-e921cf07256210d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>然后将libdlib.a拖到项目中，<strong>特别注意不要把库文件dlib目录下的文件拖进去。</strong>在文件中引用一下库文件。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include &lt;dlib/image_processing.h&gt;</div><div class="line">#include &lt;dlib/image_io.h&gt;</div></pre></td></tr></table></figure>
<p>之后会报找不到头文件。</p>
<ol>
<li><p>然后设置文件夹搜索<br><img src="http://upload-images.jianshu.io/upload_images/664334-b600e7f7db4987b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>然后编译，不出意外会报如下的错。<br><img src="http://upload-images.jianshu.io/upload_images/664334-2eb732ae1cf25bab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>添加需要的framework。非常重要。麻蛋让我踩了好久的坑。<br><img src="http://upload-images.jianshu.io/upload_images/664334-7493b62140bed4da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>然后添加<code>Custom Compiler Flags</code>中的<code>Other C Flags</code>。下面这些flag定义了在预处理阶段对libdlib.a的某些特性的宏。</p>
<ul>
<li>-DDLIB_JPEG_SUPPORT</li>
<li>-DDLIB_NO_GUI_SUPPORT</li>
<li>-DNDEBUG -DDLIB_USE_BLAS</li>
<li>-DDLIB_USE_LAPACK<br><img src="http://upload-images.jianshu.io/upload_images/664334-e33dc50275c14150.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
</li>
<li>添加预处理宏Preprocessor Macros。<ul>
<li>DLIB_JPEG_SUPPORT</li>
<li>DLIB_NO_GUI_SUPPORT</li>
<li>NDEBUG -DDLIB_USE_BLAS</li>
<li>DLIB_USE_LAPACK<br><img src="http://upload-images.jianshu.io/upload_images/664334-0e2c2fe9987b10f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
</li>
<li>现在编译就能够完全通过了。</li>
</ol>
<p>接下来就是进行代码编写实现人脸特征点提取了。下次再讲吧！</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="http://stackoverflow.com/questions/39807835/how-to-use-dlib-in-xcode-c-console-application" target="_blank" rel="external">How to use dlib in Xcode C++ console application</a><br><a href="http://www.learnopencv.com/facial-landmark-detection/" target="_blank" rel="external">Facial Landmark Detection</a><br><a href="http://stackoverflow.com/questions/23634940/opencv2-framework-not-compile-with-linker-flag-objc" target="_blank" rel="external">opencv2.framework not compile with linker flag -ObjC</a></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
            <category> face recognize </category>
            
        </categories>
        
        
        <tags>
            
            <tag> dlib </tag>
            
            <tag> face recognize </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[谈谈位枚举NS_OPTIONS]]></title>
      <url>http://yoursite.com/2017/04/22/2017/4/%E8%B0%88%E8%B0%88%E4%BD%8D%E6%9E%9A%E4%B8%BENS_OPTIONS/</url>
      <content type="html"><![CDATA[<p>给别人讲问题的时候遇到类似的，顺便就复习下。<br><a id="more"></a></p>
<h1 id="谈谈位枚举NS-OPTIONS"><a href="#谈谈位枚举NS-OPTIONS" class="headerlink" title="谈谈位枚举NS_OPTIONS"></a>谈谈位枚举NS_OPTIONS</h1><p>在iOS开发中枚举大家用得最多的应该是NS_ENUM。NS_ENUM也没什么好讲的。主要来讲讲位枚举NS_OPTIONS。</p>
<p>下面是他们在Foundation.framework的NSObjCRuntime.h的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#if (__cplusplus &amp;&amp; __cplusplus &gt;= 201103L &amp;&amp; (__has_extension(cxx_strong_enums) || __has_feature(objc_fixed_enum))) || (!__cplusplus &amp;&amp; __has_feature(objc_fixed_enum))</div><div class="line"></div><div class="line">#define NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type</div><div class="line"></div><div class="line">#if (__cplusplus)</div><div class="line"></div><div class="line">#define NS_OPTIONS(_type, _name) _type _name; enum : _type</div><div class="line"></div><div class="line">#else</div><div class="line"></div><div class="line">#define NS_OPTIONS(_type, _name) enum _name : _type _name; enum _name : _type</div><div class="line"></div><div class="line">#endif</div><div class="line"></div><div class="line">#else</div><div class="line"></div><div class="line">#define NS_ENUM(_type, _name) _type _name; enum</div><div class="line"></div><div class="line">#define NS_OPTIONS(_type, _name) _type _name; enum</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>其实从枚举定义来看，NS_ENUM和NS_OPTIONS本质是一样的，仅仅从字面上来区分其用途。NS_ENUM是通用情况，NS_OPTIONS一般用来定义具有位移操作或特点的情况（bitmask掩码)。</p>
<h2 id="与、或操作"><a href="#与、或操作" class="headerlink" title="与、或操作"></a>与、或操作</h2><p>先讲讲关于二进制的位于操作。可能好多的同学都有些忘了。这里复习下。</p>
<table>
<thead>
<tr>
<th>位操作</th>
<th>解释</th>
<th>例子</th>
<th>应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>按位与（&amp;）</td>
<td><strong>有0则0</strong>，当俩位同时为1时返回1.</td>
<td>4=0000 0000 0000 0100 &amp;7 =0000 0000 0000 0111= 0000 0000 0000 0100</td>
<td>1.清零<br>2.获取一个数据的指定位 <br>3.保留数据区的特定位<br></td>
</tr>
<tr>
<td>按位或（`</td>
<td>`）</td>
<td><strong>有1则1</strong>，只要有一位为1则即可返回1.</td>
<td>5 = 0000 0000 0000 0101`</td>
<td>` 7= 0000 0000 0000 0111=0000 0000 0000 0111</td>
<td><strong>设定一个数据的指定位</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<p>&lt;&lt;:左移运算符。左移k位 相当于 *2^k<br>＞＞:右移运算符。右移k位 相当于/2^k</p>
</blockquote>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>NS_OPTIONS位枚举的特点是可以使用位运算来处理枚举值，<strong>实际使用中可以用一个变量存储多个枚举值，表示互不影响的多个设置。</strong>比如系统中的UIViewAutoresizing定义如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">enum UIViewAutoresizing &#123;</div><div class="line">    UIViewAutoresizingNone                 = 0, // 000000</div><div class="line">    UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0, // 000001</div><div class="line">    UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,// 000010</div><div class="line">    UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,// 000100</div><div class="line">    UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,// 001000</div><div class="line">    UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,// 010000</div><div class="line">    UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5,// 100000</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了说明问题这里就用UIViewAutoresizing举个例子。上面把对应的二进制写在了后面。现在要实现视图的宽和高自适应，<code>UIViewAutoResizingFlexibleWidth| UIViewAutoresizingFlexibleHeight。</code>。</p>
<p>一般会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIViewAutoresizing resizing = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;</div></pre></td></tr></table></figure>
<p>转换为二进制计算一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIViewAutoresizing resizing = 000010 |010000 = 010010</div></pre></td></tr></table></figure>
<p>这样就实现了变量保存多个枚举值。那么如何判断变量是否包含某个枚举值了，这的通过与操作。比如我要判断是否包含了<code>UIViewAutoresizingFlexibleWidth</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (resizing &amp; UIViewAutoresizingFlexibleWidth) &#123;</div><div class="line">       // UIViewAutoresizingFlexibleWidth is set</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转换为二进制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (010010 &amp; 000010) &#123;</div><div class="line">       // UIViewAutoresizingFlexibleWidth is set</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>010010 &amp; 000010 = 000010 很明显不等于0。所以为YES。那么用一个不包含的试一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (resizing &amp; UIViewAutoresizingFlexibleTopMargin) &#123;</div><div class="line">       // UIViewAutoresizingFlexibleTopMargin is set</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转为二进制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (010010 &amp; 001000) &#123;</div><div class="line">       // UIViewAutoresizingFlexibleTopMargin is set</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很明显010010 &amp; 001000 = 0，所以能够知道resizing不包含UIViewAutoresizingFlexibleTopMargin。</p>
<p><strong>通过以上的这种方式实现了一个变量保存多个枚举值。也就是NS_OPTIONS的原理。</strong></p>
<h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><ol>
<li>枚举命名方式尽量用系统的风格，比如枚举名为UIViewAutoresizing，具体的值为UIViewAutoresizingNone。简单来讲就是（枚举名+状态）</li>
<li>如果要实现一个变量保存多个枚举值就用NS_OPTIONS。个人觉得用NS_OPTIONS完全可以替代NS_ENUM。只需要在使用的时候不用与、或操作就可以了</li>
<li>用NS_ENUM与NS_OPTIONS宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。</li>
<li>在处理枚举类型的switch语句中不要实现default分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch语句并未处理所有枚举。</li>
<li><strong>预留一个枚举值，用于扩展或者用于表示没有的情况</strong>。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
            <category> recover </category>
            
        </categories>
        
        
        <tags>
            
            <tag> base recover </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决mac下Spotlight和Notes(记事本)搜索失效]]></title>
      <url>http://yoursite.com/2017/04/17/2017/4/%E8%A7%A3%E5%86%B3mac%E4%B8%8BSpotlight%E5%92%8CNotes%E6%90%9C%E7%B4%A2%E5%A4%B1%E6%95%88/</url>
      <content type="html"><![CDATA[<p>由于换了mac，之前的习惯是把一些常用的文字资料放在Notes（记事本）中，这样可以在手机和电脑中实现资料互通。但是最近换了新mac，notes能够从Icloud中拿到同步的资料，但是始终搜索不出来。而且spotlight搜索也不起任何作用。这里记录一下解决的方法。<br><a id="more"></a></p>
<blockquote>
<p><strong>我的是英文环境，对应到中文环境应该一样的操作</strong></p>
</blockquote>
<h2 id="解决spotlight不能搜索"><a href="#解决spotlight不能搜索" class="headerlink" title="解决spotlight不能搜索"></a>解决spotlight不能搜索</h2><ol>
<li>尝试重建索引<code>sudo mdutil -E /</code>默认会建立磁盘下所有索引，如果想指定某个外接磁盘或者其他磁盘可以使用<code>sudo mdutil -E /Volumes/MiniMe/</code>对指定的磁盘建立索引。如果出现<code>invalid destination port
Spotlight server is disabled.</code>则进行下面的操作。<br> 1.1 开启Splot服务:<code>sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.metadata.mds.plist</code>。顺便提一下关闭的命令<code>sudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.metadata.mds.plist</code>，然后再建索引。</li>
<li>如果上面操作还是不行，在执行强制重建索引命令<code>sudo mdutil -a -i on</code>。我就是通过这个命令解决的。</li>
</ol>
<h2 id="解决Notes-记事本-不能搜索"><a href="#解决Notes-记事本-不能搜索" class="headerlink" title="解决Notes(记事本)不能搜索"></a>解决Notes(记事本)不能搜索</h2><p>这个问题其实是让人非常痛苦的，因为notes里面保存了自己很多的资料。解决这个问题其实很简单，<strong>将iCloud同步过来的一个文件夹，拖到on my mac下就可以了。具体方法就是，点击文件夹，按住option键，拖到on my mac下就可以了</strong></p>
<p>猜测通过这种方式，重建了对于icloud的索引，所以能够搜索到了。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="http://www.cultofmac.com/154458/re-index-spotlight-from-the-terminal-re-gain-valuable-time-for-life-os-x-tips/" target="_blank" rel="external">Re-Index Spotlight from the Terminal</a><br><a href="http://www.cultofmac.com/211559/enable-spotlight-indexing-to-re-index-your-mac-hard-drive-os-x-tips/" target="_blank" rel="external">Enable Spotlight Indexing To Re-Index Your Mac Hard Drive </a><br><a href="https://apple.stackexchange.com/questions/216462/how-can-i-force-an-index-of-all-the-apple-notes" target="_blank" rel="external">How can I force an index of all the Apple notes?</a></p>
]]></content>
      
        <categories>
            
            <category> mac </category>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tool </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS音频相关基础整理及参考文章整理]]></title>
      <url>http://yoursite.com/2017/04/16/2017/4/iOS%E9%9F%B3%E9%A2%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%E5%8F%8A%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p>来这边第一天就感受到了技术氛围浓厚，音视频方面全是用自己的服务，之前很少自己写底层的顿时，感觉压力山大。接到的第一个任务就是关于iOS音视频处理，这里简单记录下自己看过的一些音频相关知识点，视频相关后续放出。<br><a id="more"></a></p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>现实生活中，我们听到的声音都是时间连续的，我们称为这种信号叫<code>模拟信号</code>。模拟信号需要进行<code>数字化</code>以后才能在计算机中使用。目前我们在计算机上进行音频播放都需要依赖于音频文件。</p>
<p><strong>音频文件的生成过程是将<code>声音信息采样</code>、<code>量化</code>和<code>编码</code>产生的<code>数字信号</code>的过程</strong>。人耳所能听到的声音，最低的频率是从20Hz起一直到最高频率20KHZ，因此音频文件格式的最大带宽是20KHZ。根据奈奎斯特的理论，<strong>只有采样频率<code>高于</code>声音信号最高频率的两倍时，才能把数字信号表示的声音还原成为原来的声音，所以音频文件的采样率一般在40~50KHZ，比如最常见的CD音质采样率44.1KHZ。</strong></p>
<p>对声音进行采样、量化过程被称为脉冲编码调制（Pulse Code Modulation），<code>简称PCM</code>。<strong>PCM数据是最原始的音频数据完全无损</strong>，所以PCM数据虽然音质优秀但体积庞大，为了解决这个问题先后诞生了一系列的音频格式，这些音频格式运用不同的方法对音频数据进行压缩，<strong>其中有无损压缩（ALAC、APE、FLAC）和有损压缩（MP3、AAC、OGG、WMA）两种</strong>。</p>
<p>位速/比特率/码率描述的都是一个东西，<strong>是指在一个数据流中每秒钟能通过的信息量</strong>，<code>代表了压缩质量</code>，比如MP3常用码率有128kbit/s、160kbit/s、320kbit/s等等，越高代表着声音音质越好。MP3中的数据有ID3和音频数据组成，ID3用于存储歌名、演唱者、专辑、音轨等我们可以常见的信息。</p>
<h3 id="简化声音处理流程"><a href="#简化声音处理流程" class="headerlink" title="简化声音处理流程"></a>简化声音处理流程</h3><p>模拟信号 -&gt; 输入设备（传递电压值）-&gt; 声卡(经过采样跟量化（即设置声音大小等各种值）) -&gt; 磁盘（文件） -&gt; 声卡 -&gt; 输出设备 -&gt; 模拟信号</p>
<p>我们声音在物理上用波形表示，那么我们将这些波形称作为模拟信号。而我们计算机磁盘只能存储（01010101）的格式。我们将模拟信号转换成能够被磁盘存储的格式（010101）称之为数字信号。这个转换的过程我们叫模数转换。</p>
<p>我们发出来的声音（模拟信号）是连续的，我们如果要一直的对模拟信号进行转化，产生的数字信号会很大。那么我们就要采样，而<strong>采样精度就是每秒计算机对模拟信号进行采样的次数</strong>。最常见的采样精度就是上面提到的44.1khz/s,这个是经过大师们多年研究得出的数据，低于这个数据，效果就会很差，而高于这个数据，效果的差距不是很明显。</p>
<p>采样后会后是变成了（0101010110100101…），那声音的音量是有大小的，那这串数据，怎样表示声音的大小呢？ 这就涉及到了比特率，它是指在一个数据流中每秒钟能通过的信息量。 比特率就是将声音的大小划分为多少等级。举例下：8比特，在二进制中，表示有8位，表示的十进制的值就是0（00000000）～256（11111111），那每个数值就代表着一个声音大小。</p>
<blockquote>
<p>过程可以简化为：波形在经过输入设备的时候，会产生电压值。声卡通过计算采样率、比特率，以每秒几次的频率去获取这些电压值，然后将这些电压值以几bit的形式转换成数字信号。计算机将数据格式存储为文件。</p>
</blockquote>
<p><strong>文件是用来装数字信号的</strong>，文件包括了比特率、采样率、声道、编码方式、以及被编码过后的数字信号。</p>
<p>文件格式就是制造者自己规定的一种名称，在每个文件格式都会特定支持几种编码格式。<strong>打个比方就是文件就是一个容器，里面可以装不同的水，有的可以装一种，有的可以装好几种。</strong></p>
<p>经过采样后的数字信号很大，有时候我们不需要这么大的，所以我们就要进行编码压缩，当然压缩技术都是有损的。在不大影响音频的效果的情况下，<strong>舍弃掉一些高频或者低频的数据</strong>。</p>
<h3 id="采样频率-采样精度"><a href="#采样频率-采样精度" class="headerlink" title="采样频率(采样精度)"></a>采样频率(采样精度)</h3><p>采样频率是指单位时间内对声音模拟信号的采样次数。采样率类似于视频的帧数，比如电影的采样率是24Hz。<strong>当我们把采样到的一个个静止画面再以采样率同样的速度回放时，看到的就是连续的画面。</strong>同样的道理，把以44.1kHZ采样率记录的CD以同样的速率播放时，就能听到连续的声音。显然，这个采样率越高，听到的声音和看到的图像就越连贯。</p>
<h3 id="采样位数"><a href="#采样位数" class="headerlink" title="采样位数"></a>采样位数</h3><p>采样位数可以理解为采集卡处理声音的解析度。电脑中的声音文件是用数字0和1来表示的。连续的模拟信号按一定的采样频率经数码脉冲取样后，<strong>每一个离散的脉冲信号被以一定的量化精度量化成一串二进制编码流</strong>，<code>这串编码流的位数</code>即为采样位数，也称为量化精度。</p>
<h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><p>可以理解为每种音频格式不同的编解码方式，而iOS下这些编码方式被集中到一个枚举中.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">CF_ENUM(AudioFormatID)</div><div class="line">&#123;</div><div class="line">    kAudioFormatLinearPCM               = &apos;lpcm&apos;,</div><div class="line">    kAudioFormatAC3                     = &apos;ac-3&apos;,</div><div class="line">    kAudioFormat60958AC3                = &apos;cac3&apos;,</div><div class="line">    kAudioFormatAppleIMA4               = &apos;ima4&apos;,</div><div class="line">    kAudioFormatMPEG4AAC                = &apos;aac &apos;,</div><div class="line">    kAudioFormatMPEG4CELP               = &apos;celp&apos;,</div><div class="line">    kAudioFormatMPEG4HVXC               = &apos;hvxc&apos;,</div><div class="line">    kAudioFormatMPEG4TwinVQ             = &apos;twvq&apos;,</div><div class="line">    kAudioFormatMACE3                   = &apos;MAC3&apos;,</div><div class="line">    kAudioFormatMACE6                   = &apos;MAC6&apos;,</div><div class="line">    kAudioFormatULaw                    = &apos;ulaw&apos;,</div><div class="line">    kAudioFormatALaw                    = &apos;alaw&apos;,</div><div class="line">    kAudioFormatQDesign                 = &apos;QDMC&apos;,</div><div class="line">    kAudioFormatQDesign2                = &apos;QDM2&apos;,</div><div class="line">    kAudioFormatQUALCOMM                = &apos;Qclp&apos;,</div><div class="line">    kAudioFormatMPEGLayer1              = &apos;.mp1&apos;,</div><div class="line">    kAudioFormatMPEGLayer2              = &apos;.mp2&apos;,</div><div class="line">    kAudioFormatMPEGLayer3              = &apos;.mp3&apos;,</div><div class="line">    kAudioFormatTimeCode                = &apos;time&apos;,</div><div class="line">    kAudioFormatMIDIStream              = &apos;midi&apos;,</div><div class="line">    kAudioFormatParameterValueStream    = &apos;apvs&apos;,</div><div class="line">    kAudioFormatAppleLossless           = &apos;alac&apos;,</div><div class="line">    kAudioFormatMPEG4AAC_HE             = &apos;aach&apos;,</div><div class="line">    kAudioFormatMPEG4AAC_LD             = &apos;aacl&apos;,</div><div class="line">    kAudioFormatMPEG4AAC_ELD            = &apos;aace&apos;,</div><div class="line">    kAudioFormatMPEG4AAC_ELD_SBR        = &apos;aacf&apos;,</div><div class="line">    kAudioFormatMPEG4AAC_ELD_V2         = &apos;aacg&apos;,    </div><div class="line">    kAudioFormatMPEG4AAC_HE_V2          = &apos;aacp&apos;,</div><div class="line">    kAudioFormatMPEG4AAC_Spatial        = &apos;aacs&apos;,</div><div class="line">    kAudioFormatAMR                     = &apos;samr&apos;,</div><div class="line">    kAudioFormatAMR_WB                  = &apos;sawb&apos;,</div><div class="line">    kAudioFormatAudible                 = &apos;AUDB&apos;,</div><div class="line">    kAudioFormatiLBC                    = &apos;ilbc&apos;,</div><div class="line">    kAudioFormatDVIIntelIMA             = 0x6D730011,</div><div class="line">    kAudioFormatMicrosoftGSM            = 0x6D730031,</div><div class="line">    kAudioFormatAES3                    = &apos;aes3&apos;,</div><div class="line">    kAudioFormatEnhancedAC3             = &apos;ec-3&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>比较通俗的理解：封装格式和编码的关系，就是和酒瓶与酒的关系差不多，而播放器就是开酒器。为了可以喝更好的酒，最好先了解酒是什么酒，酒瓶是什么酒瓶，怎么使用开酒器开酒瓶，码率或者可以比喻做酒的原料。对于同一个酒瓶和做同一种酒的情况下，如果原料太少，又要要求用酒把酒瓶灌满，此时只好兑水了，酒的品质就会变差了。然而，如果原料太多，又会造成原料浪费。所以要做好酒，我们就需要充足的原料。</p>
<p><strong>封装格式就是文件格式，编码就是编码格式。</strong></p>
<h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><h3 id="播放流程简化"><a href="#播放流程简化" class="headerlink" title="播放流程简化"></a>播放流程简化</h3><p>这里以播放MP3文件为例：</p>
<ol>
<li>读取MP3文件</li>
<li>解析采样率、码率、时长等信息，分离MP3中的音频帧</li>
<li>对分离出来的音频帧解码得到PCM数据</li>
<li>对PCM数据进行音效处理（均衡器、混响器等，非必须）</li>
<li>把PCM数据解码成音频信号</li>
<li>把音频信号交给硬件播放<br>重复1-6步直到播放完成</li>
</ol>
<p>采集和量化的过程和上面的过程基本相反。</p>
<p>iOS对音频处理的封装</p>
<p><img src="http://msching.github.io/images/iOS-audio/api-architectural-layers.png" alt=""></p>
<p>上述模块接口说明：</p>
<ul>
<li>Audio File Services：读写音频数据，可以完成播放流程中的第2步；</li>
<li>Audio File Stream Services：对音频进行解码，可以完成播放流程中的第2步；</li>
<li>Audio Converter services：音频数据转换，可以完成播放流程中的第3步；</li>
<li>Audio Processing Graph Services：音效处理模块，可以完成播放流程中的第4步；</li>
<li>Audio Unit Services：播放音频数据：可以完成播放流程中的第5步、第6步；</li>
<li>Extended Audio File Services：<strong>Audio File Services和Audio Converter services的结合体；<br>AVAudioPlayer/AVPlayer(AVFoundation)：高级接口，可以完成整个音频播放的过程（包括本地文件和网络流播放，第4步除外）；一般我们都是在这层操作</strong></li>
<li>Audio Queue Services：高级接口，可以进行录音和播放，可以完成播放流程中的第3、5、6步；</li>
<li>OpenAL：用于游戏音频播放，基本没用到过</li>
</ul>
<h2 id="常用的第三方库"><a href="#常用的第三方库" class="headerlink" title="常用的第三方库"></a>常用的第三方库</h2><p><a href="https://github.com/syedhali/EZAudio#toc24" target="_blank" rel="external">EZAudio</a>这是OC版本，目前已经不再维护。作者转向了Swift项目<a href="https://github.com/audiokit/AudioKit" target="_blank" rel="external">AudioKit</a>。这个库也很牛逼。</p>
<h2 id="实时播放"><a href="#实时播放" class="headerlink" title="实时播放"></a>实时播放</h2><p><a href="http://www.jianshu.com/p/feeb107b6657" target="_blank" rel="external">AAC 到 PCM 音频解码</a><br><a href="http://www.jianshu.com/p/279a9e5b36b5" target="_blank" rel="external">使用AudioToolbox播放AAC</a></p>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/CoreAudioOverview/CoreAudioEssentials/CoreAudioEssentials.html#//apple_ref/doc/uid/TP40003577-CH10-SW1" target="_blank" rel="external">Core Audio Essentials</a></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><a href="http://blog.sina.com.cn/s/blog_7a162d000101befe.html" target="_blank" rel="external">IOS开发笔记之音频（一）</a><br><a href="https://brownfeng.github.io/2016/07/28/iOS%E9%9F%B3%E9%A2%91%E7%B3%BB%E5%88%97(%E5%9B%9B" target="_blank" rel="external">iOS音频系列(四)–音频的文件格式和数据格式</a>/)  基本概念解释<br><a href="https://brownfeng.github.io/2016/07/25/iOS%E9%9F%B3%E9%A2%91%E7%B3%BB%E5%88%97(%E4%B8%80" target="_blank" rel="external">iOS音频系列(一)–音频基础</a>/)  对一些基本概念的解释</p>
<p><a href="http://xuzichao.com/2015/03/15/IOS%20%E9%9F%B3%E9%A2%91%E4%B8%80%E8%A7%88/" target="_blank" rel="external">IOS 音频一览</a> 文章后面部分有对特定问题的解决，值得一看</p>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><p><a href="http://msching.github.io/blog/categories/ios-audio/" target="_blank" rel="external">iOS音频播放系列</a> 强力推荐 🎯<br><a href="http://justinyangjing.github.io/2016/07/14/iOS%E9%9F%B3%E9%A2%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%AE%9E%E6%97%B6%E8%AF%AD%E9%9F%B3%E9%80%9A%E4%BF%A1/" target="_blank" rel="external">iOS音频编程之实时语音通信</a>用到了一些偏底层的<br><a href="http://chenhu1001.github.io/archives/" target="_blank" rel="external">iOS直播系列</a><br><a href="http://www.jianshu.com/p/502a49c8dcd3" target="_blank" rel="external">iOS在线音频流播放</a>这个作者也是非常牛逼，关于图像处理和音频处理的都可以看看。</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
            <category> audio </category>
            
        </categories>
        
        
        <tags>
            
            <tag> audio </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CAShapeLayer大法(未完)]]></title>
      <url>http://yoursite.com/2017/04/06/2017/4/CAShapeLayer%E5%A4%A7%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>好久都没有研究iOS动画了，昨天看到了一个不规则view。当时就想应该是用CAShapeLayer做的。于是这里回顾一下CAShapeLayer、CADisplayLink、UIBezierPath，mask。<br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于iOS动画，已经有许许多多的例子和博客写过。这里也只是复习一下，如果深入了解。可以看一看业界一本公认的动画书籍<a href="http://download.csdn.net/detail/qqyinzhe/7357517" target="_blank" rel="external">iOS Core Animation Advanced Techniques</a>。里面的示例代码也有源码地址在<a href="https://github.com/pflnh/CoreAnimationCode" target="_blank" rel="external">CoreAnimationCode</a>。</p>
<h2 id="几个类的说明"><a href="#几个类的说明" class="headerlink" title="几个类的说明"></a>几个类的说明</h2><h3 id="CADisplayLink"><a href="#CADisplayLink" class="headerlink" title="CADisplayLink"></a>CADisplayLink</h3><ul>
<li><p>A CADisplayLink object is a timer object that allows <strong>your application to synchronize its drawing to the refresh rate of the display</strong></p>
</li>
<li><p>大致有以下几点需要注意。</p>
<ol>
<li>CADisplayLink是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器</li>
<li>一但 CADisplayLink 以特定的模式注册到runloop之后，每当屏幕需要刷新的时候，runloop就会调用CADisplayLink绑定的target上的selector，这时target可以读到  CADisplayLink 的每次调用的时间戳，用来准备下一帧显示需要的数据。</li>
<li>可以通过pause属性开控制CADisplayLink的运行。当我们想结束一个CADisplayLink的时候，应该调用-(void)invalidate从runloop中删除并删除之前绑定的 target跟selector</li>
<li>CADisplayLink 不能被继承。</li>
</ol>
</li>
<li><p>附带提一下和与 NSTimer 有什么不同</p>
<ol>
<li>NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。并且 NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间的延迟范围。</li>
<li>CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。</li>
<li>NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。</li>
</ol>
</li>
</ul>
<h3 id="UIBezierPath"><a href="#UIBezierPath" class="headerlink" title="UIBezierPath"></a>UIBezierPath</h3><ul>
<li>The UIBezierPath class lets you define a path consisting of straight and curved line segments and render that path in your custom views. You use this class initially to specify just the geometry for your path. Paths can define simple shapes such as rectangles, ovals, and arcs or they can define complex polygons that incorporate a mixture of straight and curved line segments. After defining the shape, you can use additional methods of this class to render the path in the current drawing context.</li>
</ul>
<p>建议先看看<a href="http://blog.csdn.net/crayondeng/article/details/11093689" target="_blank" rel="external">iOS UIBezierPath类 介绍</a></p>
<p> UIBezierPath类可以创建基于矢量的路径，它是Core Graphics框架关于CGPathRef类型数据的封装，利用它创建直线或者曲线来构建我们想要的形状，每一个直线段或者曲线段的结束位置就是下一个线段开始的地方。这些连接的直线或者曲线的集合成为subpath。一个UIBezierPath对象的完整路径包括一个或者多个subpath。</p>
<p>使用步骤：</p>
<ol>
<li>创建一个Bezier Path对象。</li>
<li>使用方法moveToPoint:去设置初始线段的起点。</li>
<li>添加line或者curve去定义一个或者多个subpath。</li>
<li>修改UIBezierPath对象跟绘图相关的属性。</li>
</ol>
<h3 id="CAShapeLayer"><a href="#CAShapeLayer" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h3><ul>
<li>A layer that draws a cubic Bezier spline in its coordinate space</li>
</ul>
<p>建议先看看<a href="http://www.cnblogs.com/YouXianMing/p/3678709.html" target="_blank" rel="external">CAShapeLayer</a></p>
<p>CAShapeLayer是一个通过矢量图形而不是bitmap来绘制的图层子类。CAShapeLayer可以用来绘制所有通过CGPath来表示的形状，上面讲到了可以用UIBezierPath来创建任何你想要的路径，使用CAShapeLayer的属性path配合UIBezierPath创建的路径，就可以呈现出我们想要的形状。</p>
<p><strong>这个形状不一定要闭合，图层路径也不一定是连续不断的，你可以在CAShapeLayer的图层上绘制好几个不同的形状</strong>，但是你只有一次机会去设置它的path、lineWith、lineCap等属性，如果你想同时设置几个不同颜色的多个形状，你就需要为每个形状准备一个图层。</p>
<h3 id="mask"><a href="#mask" class="headerlink" title="mask"></a>mask</h3><ul>
<li>An optional layer whose alpha channel is used to mask the layer’s content.</li>
<li>The layer’s alpha channel determines how much of the layer’s content and background shows through. Fully or partially opaque pixels allow the underlying content to show through but fully transparent pixels block that content.</li>
</ul>
<p>建议先看看<a href="https://zsisme.gitbooks.io/ios-/content/chapter4/layer-masking.html" target="_blank" rel="external">图层蒙板</a></p>
<p>CALayer有一个属性叫做mask，通常被称为蒙版图层，这个属性本身也是CALayer类型，有和其他图层一样的绘制和布局属性。它类似于一个子视图，相对于父图层（即拥有该属性的图层）布局，但是它却不是一个普通的子视图。不同于一般的subLayer，mask定义了父图层的可见区域，简单点说就是最终父视图显示的形态是父视图自身和它的属性mask的交集部分。</p>
<p>mask图层的color属性是无关紧要的，<strong>真正重要的是它的轮廓</strong>，mask属性就像一个切割机，父视图被mask切割，相交的部分会留下，其他的部分则被丢弃。</p>
<p><strong>CALayer的蒙版图层真正厉害的地方在于蒙版图层不局限于静态图，任何有图层构成的都可以作为mask属性，这意味着蒙版可以通过代码甚至是动画实时生成。</strong></p>
<h2 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h2><p>TODO</p>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="http://summertreee.github.io/blog/2016/08/07/dong-hua-huang-jin-da-dang-cadisplaylink-and-cashapelayer/" target="_blank" rel="external">动画黄金搭档:CADisplayLink &amp; CAShapeLayer</a><br><a href="http://www.cocoachina.com/ios/20160711/17007.html" target="_blank" rel="external">关于CAShapeLayer的一些实用案例和技巧</a><br><a href="http://www.cocoachina.com/ios/20160214/15251.html" target="_blank" rel="external">放肆地使用UIBezierPath和CAShapeLayer画各种图形</a></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
            <category> animation </category>
            
        </categories>
        
        
        <tags>
            
            <tag> animation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自己整理iOS 常用第三方（持续更新...）]]></title>
      <url>http://yoursite.com/2017/04/06/2017/4/%E8%87%AA%E5%B7%B1%E6%95%B4%E7%90%86iOS%20%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9/</url>
      <content type="html"><![CDATA[<p>网上有很多整理使用第三方库的文章，毕竟是别人使用的，有一些做iOS家喻户晓的比如AFNetworking、SDWebImage，SpringPop这里就不用罗列了。这里主要总结一下自己平时用到的一些第三方，或者自己觉得很有学习必要的第三方。<br><a id="more"></a></p>
<h1 id="自己整理iOS-常用第三方-持续更新…-⭐️💖🏅"><a href="#自己整理iOS-常用第三方-持续更新…-⭐️💖🏅" class="headerlink" title="自己整理iOS 常用第三方(持续更新…)⭐️💖🏅"></a>自己整理iOS 常用第三方(持续更新…)⭐️💖🏅</h1><ul>
<li><a href="http://alcatraz.io/" target="_blank" rel="external">Alcatraz插件管理</a></li>
<li><a href="https://github.com/alcatraz/Alcatraz/issues/498" target="_blank" rel="external">GitHub Alcatraz</a></li>
</ul>
<h2 id="一、UI"><a href="#一、UI" class="headerlink" title="一、UI"></a>一、UI</h2><h3 id="广告引导"><a href="#广告引导" class="headerlink" title="广告引导"></a>广告引导</h3><ul>
<li><a href="https://github.com/CoderZhuXH/XHLaunchAd" target="_blank" rel="external">XHLaunchAd</a> github最高star</li>
<li><a href="https://github.com/AllLuckly/LBLaunchImageAd" target="_blank" rel="external">LBLaunchImageAd</a>功能不是很强大的，但是满足需求了</li>
<li><a href="https://github.com/12207480/TYLaunchAnimation" target="_blank" rel="external">TYLaunchAnimation</a>相比上面的，功能更少</li>
<li><a href="https://github.com/amber01/WSDrawCircleProgress" target="_blank" rel="external">WSDrawCircleProgress</a>启动右上角原型</li>
</ul>
<h3 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h3><ul>
<li><a href="https://github.com/gsdios/SDCycleScrollView" target="_blank" rel="external">SDCycleScrollView</a>传统轮播图</li>
<li><a href="https://github.com/PageGuo/NewPagedFlowView" target="_blank" rel="external">NewPagedFlowView</a>视差轮播图</li>
</ul>
<h3 id="提示框"><a href="#提示框" class="headerlink" title="提示框"></a>提示框</h3><ul>
<li><a href="https://github.com/wimagguc/ios-custom-alertview" target="_blank" rel="external">ios-custom-alertview</a></li>
<li><a href="https://github.com/lmcd/LMAlertView" target="_blank" rel="external">LMAlertView</a></li>
</ul>
<h3 id="下载进度提示"><a href="#下载进度提示" class="headerlink" title="下载进度提示"></a>下载进度提示</h3><ul>
<li><p><a href="https://github.com/PavelKatunin/DownloadButton" target="_blank" rel="external">DownloadButton</a><br>  <img src="https://cloud.githubusercontent.com/assets/1636737/7920830/2c4470da-08aa-11e5-99be-e7e9a04479f8.png" alt=""></p>
</li>
<li><p><a href="https://github.com/Guidebook/gbkui-button-progress-view" target="_blank" rel="external">gbkui-button-progress-view</a><br>  <img src="https://camo.githubusercontent.com/c21307792a960e90d630440e09d308d7c854dac3/687474703a2f2f706574656c6164612e636f6d2f696d616765732f706c6164612d6c6f6164696e672d627574746f6e2e676966" alt=""></p>
</li>
<li><p><a href="https://github.com/Josin22/JSDownloadView" target="_blank" rel="external">JSDownloadView</a><br>  <img src="https://raw.githubusercontent.com/Josin22/JSDownloadView/master/JSDownloadViewDemo/Source/download.gif" alt=""></p>
</li>
<li><a href="https://github.com/daria-kopaliani/DAProgressOverlayView" target="_blank" rel="external">DAProgressOverlayView</a><br>  <img src="https://github.com/daria-kopaliani/DAProgressOverlayView/raw/master/DAProgressOverlayView.gif" alt=""></li>
<li><a href="https://github.com/Karthus1110/ZYDownloadProgress" target="_blank" rel="external">ZYDownloadProgress</a><br>  <img src="https://camo.githubusercontent.com/f457fa6aeb5b8e67bd3f01bb95d41eb0edbc7aad/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313234393530352d613134336261316535333063653337322e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970" alt=""></li>
<li><a href="https://github.com/sgryschuk/SGNavigationProgress" target="_blank" rel="external">SGNavigationProgress</a>:导航栏下面进度条<br><img src="https://camo.githubusercontent.com/8a1b67ef84b0353148e89dcbea6b44b22292ac07/68747470733a2f2f7261772e6769746875622e636f6d2f73677279736368756b2f53474e617669676174696f6e50726f67726573732f6d61737465722f53637265656e53686f744d61736b2e706e67" alt=""><h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3></li>
<li><a href="https://github.com/kevinzhow/PNChart" target="_blank" rel="external">PNChart</a>：国人写的。目前是GitHub排名第一个iOS图表类三方库<br><img src="https://camo.githubusercontent.com/a0c2be4b0b43f84c920e983009ef4c260e234307/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f666172736869642e67686f64732e6769746875622f706e63686172742d6c696e6563686172742d736d6f6f74682e706e67" alt=""><h3 id="区段滑动"><a href="#区段滑动" class="headerlink" title="区段滑动"></a>区段滑动</h3><a href="https://github.com/maxep/MXSegmentedPager" target="_blank" rel="external">MXSegmentedPager</a><br><img src="https://github.com/maxep/MXSegmentedPager/blob/master/Example-objc/SimpleView.gif" alt=""></li>
</ul>
<h2 id="二、应用设置"><a href="#二、应用设置" class="headerlink" title="二、应用设置"></a>二、应用设置</h2><h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><ul>
<li><a href="https://github.com/stefanceriu/SCStringsUtility" target="_blank" rel="external">SCStringsUtility</a> 快速国际化，通过导入CSV实现快捷导入。</li>
</ul>
<h2 id="三、编程语法"><a href="#三、编程语法" class="headerlink" title="三、编程语法"></a>三、编程语法</h2><ul>
<li><a href="https://github.com/qddnovo/LinkBlock" target="_blank" rel="external">LinkBlock</a>  <strong>这个比较优秀</strong><br>objc链式编程语法糖扩展，旨在将冗余逻辑集中，专注于编码的逻辑，使代码结构清晰。</li>
<li><a href="https://github.com/Draveness/ChainableKit" target="_blank" rel="external">ChainableKit</a><br>ChainableKit is a convience way to set up UIKit component with chainable syntax. This framework is inspired by Masonry and JHChainableAnimations.</li>
<li><a href="https://github.com/jhurray/JHChainableAnimations" target="_blank" rel="external">JHChainableAnimations</a><br>Easy to read and write chainable animations in Objective-C and Swift</li>
</ul>
<h2 id="四、网络"><a href="#四、网络" class="headerlink" title="四、网络"></a>四、网络</h2><ul>
<li><a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="external">YTKNetwork</a> 对AF的二次封装，猿题库开源，值得学习</li>
<li><a href="https://github.com/casatwy/RTNetworking" target="_blank" rel="external">RTNetworking</a>在iOS架构系列文章中，作者给出了自己的方案，这个网络库就是他的为网络层解耦所写，和YTKNetwork有些类似，适合一些大型项目。</li>
<li><a href="https://github.com/ShelinShelin/OffLineCache" target="_blank" rel="external">OffLineCache</a>数据库离线缓存思路，以及AFN的再次封装，离线状态时从数据库加载数据</li>
<li><a href="https://github.com/jkpang/PPNetworkHelper" target="_blank" rel="external">PPNetworkHelper</a>AFNetworking 3.x 与YYCache封装,一句代码搞定数据请求与缓存,告别FMDB!控制台直接打印json中文字符。但bug是有点多。</li>
</ul>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><ul>
<li><a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="external">CocoaAsyncSocket</a>：对Socket完全封装</li>
</ul>
<h2 id="五、分类（Category）"><a href="#五、分类（Category）" class="headerlink" title="五、分类（Category）"></a>五、分类（Category）</h2><ul>
<li><a href="https://github.com/shaojiankui/JKCategories" target="_blank" rel="external">JKCategories</a>包含了”JKUIKit.h”,”JKFoundation.h”,”JKCoreData.h”,”JKCoreLocation.h”,”JKMapKit.h”,”JKQuartzCore.h”，比较强大除此之外还有YYKit里面也有许多类似的</li>
<li><a href="https://github.com/brentsimmons/QSKit" target="_blank" rel="external">QSKit</a>star没有上面这个多，里面也有挺多可以看得</li>
</ul>
<h2 id="六、动画"><a href="#六、动画" class="headerlink" title="六、动画"></a>六、动画</h2><ul>
<li><a href="https://github.com/YouXianMing/Animations" target="_blank" rel="external">Animations</a> ⭐️⭐️⭐️基本上涵盖了iOS用到的所有动画效果，而且还有一个开源的天气类型app<a href="https://github.com/YouXianMing/YoCelsius" target="_blank" rel="external">YoCelsius</a>。作者的博客里面也有很多关于动画方面的文章写得不错。<a href="http://www.cnblogs.com/YouXianMing/tag/%E5%8A%A8%E7%94%BB/" target="_blank" rel="external">动画</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
            <category> animation </category>
            
        </categories>
        
        
        <tags>
            
            <tag> animation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[typeof、 __typeof 、及__typeof __的区别]]></title>
      <url>http://yoursite.com/2017/04/05/2017/4/typeof%E5%90%84%E4%B8%AA%E4%B8%8D%E5%90%8C/</url>
      <content type="html"><![CDATA[<p>这个问题是一个同事在看一些第三方源码的时候产生的疑惑，顺便就问了我。<br><a id="more"></a></p>
<h1 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h1><p><code>__typeof__()</code>和<code>__typeof()</code>是对c语言的编译扩展，因为标准的c没有包含这样的操作符。标准c要求会对带有双下划线进行编译器预处理，这也是为什么我们在命名自己的方法和变量的时候不能用双下划线。</p>
<p><code>typeof()</code>准确来讲是和上面两者相同，只是更加强调了这个特性，而这个特性是几乎每一个现代编译器都支持的。<code>typeof()</code>也是对c的扩展，如果用<code>Objective-c</code>写代码，将会用<code>Clang</code>编译器。</p>
<p>Clang是不支持<code>typeof()</code>的使用，但是从技术上讲，他是在c语法被设置为<code>gnu</code>类型会起作用。然而<code>__typeof__()</code>是支持<code>c和gnu</code>语法。</p>
<p>如果用Xcode作为IDE，默认为c语法设置的是<code>GNU99</code>，而且<code>&#39;asm&#39; &#39;inline&#39; &#39;typeof&#39;</code>选项是<code>YES</code>。所以使用<code>typeof()</code>不会有任何问题。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/664334-f073ff010fb7316e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如果想更为安全的使用<code>Clang</code>编译器，那么就使用<code>__typeof__()</code>。这样的话就不会当你有人关掉<code>typeof</code>选项的时候造成的影响。</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
            <category> issue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> compiler </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[最近遇到的问题]]></title>
      <url>http://yoursite.com/2017/04/05/2017/4/%E6%9C%80%E8%BF%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>记录一下最近遇到的问题。<br><a id="more"></a></p>
<h1 id="libpng-error-CgBI-unhandled-critical-chunk"><a href="#libpng-error-CgBI-unhandled-critical-chunk" class="headerlink" title="libpng error: CgBI: unhandled critical chunk"></a>libpng error: CgBI: unhandled critical chunk</h1><p>这个错是出现在Xcode7.3之后。解决办法：在buildsetting里面，将<code>Remove Text Metadata From PNG Files</code>的值改为<code>NO</code>。默认值为YES.</p>
<p>因为Xcode7.3之后，默认会将元数据从png格式的文件中移除。</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
            <category> issue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> png </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[技术博客阅读笔记iOS篇(一、MRPEAK)]]></title>
      <url>http://yoursite.com/2017/04/05/2017/4/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>每天阅读那么多的博客，为什么自己对其中优秀的博客做一个笔记方便自己翻阅呢。而且牛逼的博主，其他文章含量金量也很高。虽然看博客不如看技术书籍来的全面、系统，读完之后也有不少的收获。关于泛读和精读，下面有篇文章有相应的介绍……<br><a id="more"></a></p>
<h2 id="博主MRPEAK"><a href="#博主MRPEAK" class="headerlink" title="博主MRPEAK"></a><a href="http://mrpeak.cn/" target="_blank" rel="external">博主MRPEAK</a></h2><p>一下内容大部分是摘自博客原文，如需细致阅读，建议看原文。<br><a href="http://mrpeak.cn/Archives/" target="_blank" rel="external">历史文章合集</a></p>
<h3 id="一、-如何设计一个通讯协议"><a href="#一、-如何设计一个通讯协议" class="headerlink" title="一、 如何设计一个通讯协议"></a><a href="http://mrpeak.cn/blog/tcp-rpc-protocol/" target="_blank" rel="external">一、 如何设计一个通讯协议</a></h3><p>幸好作者提供了项目源码，可以直接看源码<a href="https://github.com/music4kid/TKeyboard" target="_blank" rel="external">TKeyboard</a></p>
<p>google一搜如何设计一个通讯协议，出现了一大片文章。这里摘取比较有代表性的。<br>找到一个牛逼哄哄的网站<a href="http://www.52im.net/" target="_blank" rel="external">即时通信网</a>，做了IM这么久现在才知道有这样好资源。</p>
<p><a href="http://www.52im.net/thread-283-1-1.html" target="_blank" rel="external">理论联系实际：一套典型的IM通信协议设计详解</a><br><a href="http://gcloud.qq.com/forum/topic/56976ee6ceddce8561c9494d" target="_blank" rel="external">如何设计一个RPC系统</a></p>
<p>应用层常见的有三种：文本协议（Http）、二进制协议(ip)、流式XML协议（xmpp）。他们的各自优缺点可以大致总结出来。后文建议<a href="http://www.52im.net/thread-277-1-1.html" target="_blank" rel="external">强列建议将Protobuf作为你的即时通讯应用数据传输格式</a></p>
<p>工作内容主要有：一是数据的序列化，即将我们平时所用的 model 转化为二进制流，其二是定义好包的格式，在通讯框架里做好包的切割，解析，和传递。最后简化调用流程，提供一套简单的类似 http 的双向数据调用 API 即可。</p>
<ul>
<li>基本思路<ol>
<li>第一个序列化的问题好解决，<strong>已有 google 的成熟方案 protobuf 可以使用（感觉业界都推荐用这个，但是之前在iOS端用过，发现了很多坑爹的地方）</strong>，而且还有基于 Objective C 的版本，model 的序列化和反序列化，一个 API 调用即可完成。</li>
<li>第二个问题是包的格式定义。学习 TCP/IP 的意义在这里就能体现了，无论是 TCP 包还是 IP 包，都有自己的包格式定义，而且往往是一个 header 配合一个 payload（类似于 http 的 body）。之所以要有包，是因为二进制流只完成 stream 的传输，并不知道一次数据请求与相应的起始和结束，我们要预先定义好包结构才能做解析。</li>
<li>要能实现包的准确切割，我们需要明确包的长度。所以必须在 header 中留一个字段，表达整个包（header + payload）由多少 bytes 构成，两个字节的长度就可以描述 0~65535 个字节数，具体使用多少个字节就看协议的使用场景了。</li>
<li>因为是 RPC 调用协议，所以包体里必须有调用的名称，即 API name 字段，这个 name 是可变长度，所以也需要将其长度信息加入包体中，原则上，所有可变长度的内容都需记录其精确的长度信息，否则无法做信息的切割。另外，调用方还需要知道包是请求的回应（response）还是另一端的通知（notify），所以我们还需要定义 call type 信息，这种信息一个 8 比特位的枚举量就绰绰有余了，这种固定长度的信息就不需要记录其长度信息了。</li>
<li>一般固定长度的信息我们放在 header 中，可变长度的信息我们则放入 payload 中，当然，我们 RPC 调用的具体参数（经由 protobuf 序列化之后的 stream）也是放入 payload 中，接收方接收以后，只需读取固定长度的字节，即可通过反序列化，再在接收方还原成具体的应用层数据。</li>
</ol>
</li>
</ul>
<p>特别注意：<strong>因为我们是在设计应用层协议，所以还需要考虑传输层是可靠还是不可靠，CoreBlueTooth 实际上既提供了类似于 TCP 的可靠传输（CBCharacteristicPropertyIndicate），也有类似于 UDP 的不可靠传输（CBCharacteristicPropertyNotify），不明白这一点，必然会踩坑</strong></p>
<h3 id="二、TCP-IP-系列之重新认识-IP-地址"><a href="#二、TCP-IP-系列之重新认识-IP-地址" class="headerlink" title="二、TCP/IP 系列之重新认识 IP 地址"></a><a href="http://mrpeak.cn/blog/tcp-ip/" target="_blank" rel="external">二、TCP/IP 系列之重新认识 IP 地址</a></h3><p>大学里面网络基础学过，但是基本上都忘记了。看到这篇突然想起了一些<code>远古</code>的记忆。</p>
<blockquote>
<p>internet 其实是由无数个子网所构成，是一个二级的结构，第一级是子网，第二级才是子网中的设备。所以 internet 中设备 A 的信息要抵达设备 B，必须先要找到 B 所在的子网，进而再在子网中找到 B。</p>
</blockquote>
<p>IP 地址的结构：IP 地址 = 网络地址 + 主机地址。子网掩码（subnet mask） 就是为了分割 Network ID 和 Host ID 的</p>
<h4 id="第一种切割方式"><a href="#第一种切割方式" class="headerlink" title="第一种切割方式"></a>第一种切割方式</h4><ul>
<li>第一个字节为 Network ID，剩下三个字节为 Host ID</li>
<li>第二个字节为 Network ID，剩下两个字节为 Host ID</li>
<li><p>第三个字节为 Network ID，剩下一个字节为 Host ID<br>有问题</p>
</li>
<li><p>我们如何确定一个 IP 地址是属于 A B C 的哪一类呢？我们以第一个字节来做一些约定：</p>
<ol>
<li>如果第一个字节的起始比特位为 0，则是 A 类地址。</li>
<li>如果第一个字节的起始比特位为 10，则是 B 类地址。</li>
<li>如果第一个字节的起始比特位为 110，则是 C 类地址。</li>
</ol>
</li>
</ul>
<h4 id="第二种切割方式CIDR"><a href="#第二种切割方式CIDR" class="headerlink" title="第二种切割方式CIDR"></a>第二种切割方式CIDR</h4><p>全称为 Classless Inter-Domain Routin。CIDR 是新的子网掩码的表达方式和路由方式。这里注意 CIDR 和 CIDR notation 的区别，CIDR notation 是描述 IP 地址如何切割的方式，而 CIDR 描述的是基于 CIDR notation 的路由方式。</p>
<p>CIDR notation 其实概念也很直白，它不再粗暴的以字节为粒度来切分 IP 地址，而是精确到 bit 位，我们看一个典型的 CIDR notation：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">123.121.114.144/23</div></pre></td></tr></table></figure>
<p>注意 IP 地址后面的 /23，这就是 CIDR notation，<strong>它表示 IP 地址的前 23 bits 为 Network ID，剩余的 9 bits 为 Host ID。23 并不是 8 的倍数，我们将切分的精读提高到了 bit。</strong>我们可以通过简单的位运算，得到具体的 Network ID 和 Host ID，我们将 IP 地址和 /23 先转为二进制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">01111011.01111001.01110010.10010000 IP 地址</div><div class="line">11111111.11111111.11111110.00000000 /23 subnet mask</div></pre></td></tr></table></figure>
<p>得到 Network ID 和 Host ID：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">01111011.01111001.01110010.00000000 Network ID</div><div class="line">00000000.00000000.00000000.10010000 Host ID</div></pre></td></tr></table></figure>
<blockquote>
<p>再将二进制转换为十进制，我们就得到了便于理解的 Network ID：123.121.114.0。由于 Host ID 占用 9 个 bits，这个子网里一共可以有 2 的 9 次方个主机数，也就是 512 个主机，这个子网网段的起始地址为 123.121.114.0，结束地址为 123.121.115.255。我们对于某一个网段内的 IP 地址，有个约定，第一个地址为 Network ID，最后一个地址是该子网内的 Broadcast ID，那么剩下的可用于子网内设备的 IP 地址数量就是 510 个了。</p>
</blockquote>
<p>IP 地址虽然只是一个二级的结构，但 IP 地址的分配却是一层一层，经历多层往下分发的，由一个国际机构 IANA 统一分配。具体规则可以参考 IANA 官网：<a href="https://www.iana.org/numbers" target="_blank" rel="external">https://www.iana.org/numbers</a></p>
<p>用户拿到 IP 地址后，所发送包要经过一个个的路由器才能抵达正确的地址。</p>
<h3 id="三、TCP-IP-系列之-Header-篇"><a href="#三、TCP-IP-系列之-Header-篇" class="headerlink" title="三、TCP/IP 系列之 Header 篇"></a><a href="http://mrpeak.cn/blog/tcp-headers/" target="_blank" rel="external">三、TCP/IP 系列之 Header 篇</a></h3><p><img src="http://www.mrpeak.cn/images/ws03.png" alt=""></p>
<p>如果以一个 HTTP 请求为例，右图中 Application 部分就代表我们用 Charles 抓包时所感知的部分，这一部分要最后转化为光信号，在光纤中传输，还需要经过一层层的转化，这个转化过程说白了，就是在每一层加上一个 header。</p>
<ul>
<li>Application 层（HTTP）的数据在经过传输层（TCP Layer）的时候，会加上 TCP 的 header，成为一个 TCP Segment。</li>
<li>传输层（TCP）的 Segment 在经过网络层（IP Layer）的时候，会加上 IP 的 header，成为一个 IP Packet。</li>
<li>网络层的 IP Packet 在经过链路层（Link Layer）的时候，会加上Link Layer 的 header，成为一个 Frame。</li>
<li>最后 Frame 会在物理层，将数字信号转化为物理信号传输。</li>
</ul>
<p>看张图片一切就明了了<br><img src="http://www.mrpeak.cn/images/ws05.png" alt=""></p>
<p>深入研究可以看<a href="http://www.cnblogs.com/zhuimengle/p/5737848.html" target="_blank" rel="external">TCPdump抓包命令详解</a><br><a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html" target="_blank" rel="external">Linux tcpdump命令详解</a></p>
<h3 id="四、TCP-IP-系列之初印象"><a href="#四、TCP-IP-系列之初印象" class="headerlink" title="四、TCP/IP 系列之初印象"></a><a href="http://mrpeak.cn/blog/tcp-preface/" target="_blank" rel="external">四、TCP/IP 系列之初印象</a></h3><p>0 和 1 是计算机世界的基础粒子，大量的 0 和 1 组合在一起就形成了一个流（Stream），客户端向服务器发送数据的时候，说白了就是一堆 0 和 1 的组合。一次完整的 http 会话是建立在一个 TCP 连接之上，这个 TCP 连接的生命周期内所有发送的数据最后可以看做是一个流。<strong>而在这个流里，我们可以按照某种规则把它切割成一个个的包（packet）。</strong>比如 TCP 三次握手里就包含了 SYN，SYN+ACK，ACK 三个包，而这三个包，不过是整个 TCP Stream 最开始的部分数据而已。</p>
<p>所以简单来说，一个 TCP 连接里，是既有流的概念，又有包的存在，有些问题场景下会谈论流，另一些则会说起包，端看具体的场景如何。</p>
<p>客户端和服务器之间有两根管道，一根上行（从客户端到服务器），一根下行（从服务器到客户端），管道里流动着无数的 0 和 1，有时候管道里是满的，有时候管道里则空空如也，每次发送数据，都会有大量的 0 和 1 从一端涌向另一端。</p>
<h4 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h4><p>由两部分组成的，其一是 Transmission Delay，另一个是 Propagation Delay。</p>
<p>Transmission Delay。计算机世界里的 0 和 1， 最后要能在光纤中传输，需要在 Physical Layer 将数字信号转化为物理信号，这个转化也是存在速度瓶颈的，我们用 Rate (bits/seconds) 来描述这个转化的速度，Rate 表示每一秒钟里，硬件设备能将多少 bits 转化为光信号放入光纤中。</p>
<p> Propagation Delay。这才是大部分人所理解的传播延迟，和距离直接相关。</p>
<h3 id="五、技术文章的阅读姿势🍎"><a href="#五、技术文章的阅读姿势🍎" class="headerlink" title="五、技术文章的阅读姿势🍎"></a><a href="http://mrpeak.cn/blog/ios-tech-article/" target="_blank" rel="external">五、技术文章的阅读姿势</a>🍎</h3><p>作者和自己的感想比较相似，关于泛读和精读给出了自己的解释。对于自己而言，确实是这样，总结出来的经验也非常值得自己借鉴。</p>
<p>由于技术的知识体系往往是个树形的结构，单个术语下都有其相关的知识域，可以一层又一层牵扯出更多的子术语。在阅读文章遭遇这种树形结构的时候，要能抑制住自己不停探索的欲望，<strong>对于技术术语的学习只做适度延伸，最终的目的还是在于完成根部文章的阅读。</strong>尽量只做一到两层的延伸。</p>
<p>尽量选择没人打扰的时间段来做阅读，可以是早上刚到公司，或者别人午睡时，总之越安静，越没人找越好。</p>
<blockquote>
<p><strong>对于基础知识的阅读，要重官方文档，切莫心急动手，看完文档形成知识体系后再写代码不迟。</strong>减少泛读行为，避免漫无目的的随意浏览技术文章。注重精读，一天一篇不算少，一周一篇也正常。<strong>重阅读质量而非数量，挑选每天安静且不易被打断的时间点来阅读，尽量多啃原版书。</strong></p>
</blockquote>
<h2 id="今天的阅读就到这里了-2017-4-5-pm5-22-下次继续更新"><a href="#今天的阅读就到这里了-2017-4-5-pm5-22-下次继续更新" class="headerlink" title="今天的阅读就到这里了 2017-4-5  pm5:22  下次继续更新"></a>今天的阅读就到这里了 2017-4-5  pm5:22  下次继续更新</h2><blockquote>
<p>时隔一个多月</p>
</blockquote>
<h3 id="六、闲聊-Hash-算法"><a href="#六、闲聊-Hash-算法" class="headerlink" title="六、闲聊 Hash 算法"></a><a href="http://mrpeak.cn/blog/hash/" target="_blank" rel="external">六、闲聊 Hash 算法</a></h3><blockquote>
<p>数据结构和算法是相辅相成的，基础的其实就那么些：时间复杂度的概念，List，Array，Stack，Queue，Tree 等。Graph 实际应用中较少遇到，可以不做深入了解，但 BFS，DFS，Dijkstra 还是应该知道。基础的算法需要能达到手写的程度，比如排序至少能写出两种时间复杂度为 N*logN 的算法。理解这些比去 leetcode 刷题重要，学习难度也并不高。学习这些的意义在于掌握解决问题的基础思路，形成计算机思维，比如 divide and conque，recursive 等常规思想。</p>
</blockquote>
<h3 id="七、Improving-Immutable-Object-Initialization-in-Objective-C"><a href="#七、Improving-Immutable-Object-Initialization-in-Objective-C" class="headerlink" title="七、Improving Immutable Object Initialization in Objective-C"></a><a href="http://holko.pl/2015/05/12/immutable-object-initialization/" target="_blank" rel="external">七、Improving Immutable Object Initialization in Objective-C</a></h3><ol>
<li>Initializer mapping arguments to properties</li>
<li>Initializer taking dictionary</li>
<li>Mutable subclass</li>
<li>Improving builder pattern</li>
</ol>
<h3 id="八、危险的UITableView"><a href="#八、危险的UITableView" class="headerlink" title="八、危险的UITableView"></a><a href="http://mrpeak.cn/blog/tableview-danger/" target="_blank" rel="external">八、危险的UITableView</a></h3><p>总体来说就是调用了tableView的reloadData方法之后，代理方法有些不是同步执行的。具体来讲。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">当我们reloadData的时候，我们本意是刷新UITableView，随后会进入一系列UITableViewDataSource和UITableViewDelegate的回调，其中有些是和reloadData同步发生的，有些则是异步发生的。</div><div class="line"></div><div class="line">我们熟悉的下面两个回调是同步的：</div><div class="line"></div><div class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">    return 20;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section</div><div class="line">&#123;</div><div class="line">    return _arr.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">而另一个最常使用的回调则是异步的：</div><div class="line"></div><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">   //...</div><div class="line">   NSNumber* content = _arr[indexPath.row];</div><div class="line">   //...</div><div class="line">&#125;</div><div class="line">经过上面的分析，我们不难UITableView的危险之处在于哪了，在于异步执行cellForRowAtIndexPath的时候，我们所依赖的状态可能会发生变化，上面代码中的_arr如果元素被修改过，极有可能发生数组越界的异常。</div></pre></td></tr></table></figure>
<p>优化方案</p>
<p>throttle机制，控制刷新事件的产生频率，建立一个Queue以一定的时间间隔来调用reloadData。事实上这是一种很常见的界面优化机制，对于一些刷新频率可能很高的列表界面，比如微信的会话列表界面，如果很长时间没有登录了，打开App时，堆积了很久的离线消息会在短时间内，导致大量的界面刷新请求，频繁的调用reloadData还会造成界面的卡顿，所以此时建立一个FIFO的Queue，以一定的间隔来刷新界面就很有必要了。</p>
<h3 id="九、iOS当中的Cache设计"><a href="#九、iOS当中的Cache设计" class="headerlink" title="九、iOS当中的Cache设计 "></a><a href="http://mrpeak.cn/blog/ios-cache/" target="_blank" rel="external">九、iOS当中的Cache设计 </a></h3><p>需要看看<a href="https://my.oschina.net/huangyong/blog/177559" target="_blank" rel="external"> 一个简单的 Cache 淘汰策略</a><br>副作用的理解：</p>
<blockquote>
<p>所有对我们整个App有副作用的代码都需要被集中管理，要能从架构的层面去理解和定位。怎么去定义副作用呢？<strong>可以抽象成一种「写操作」，往Cache中添加新的记录就是写操作，这种写操作的副作用是额外的内存开销</strong>，Cache的本质是以空间换时间，这空间损耗就是我们的副作用，一个副作用会引发其他更多的副作用，理清这些副作用往往需要反复查阅大量的代码。更好的办法是，一开始就把有副作用的代码集中管理。</p>
</blockquote>
<ul>
<li>cache的另一个重要知识点是cache的淘汰策略，不同的策略表现也不一样，FIFO，LRU，2Queues等等，现在有不少成熟的第三方cache框架可以使用，系统也提供了淘汰策略不明确的NSCache。</li>
<li><p><strong>cache的使用要有收有放，不能只创建不释放，事实上，所有涉及到data的操作都要考虑data的生命周期。我们做业务的时候，多是以Controller为基础单位，有些场景下，一个Controller在退出之后被再次进入的可能性就非常之低了，适时的清理cache会让我们App的整体表现更好。</strong></p>
</li>
<li><p>只要保证业务模块从Cache中获取的数据都是独立的copy，就能避免数据共享带来的各种隐患。</p>
</li>
</ul>
<p>最后看一下<a href="https://github.com/ibireme/YYCache" target="_blank" rel="external">YYCache</a>加深学习</p>
<h3 id="十、如何用Xcode8解决多线程问题"><a href="#十、如何用Xcode8解决多线程问题" class="headerlink" title="十、如何用Xcode8解决多线程问题"></a><a href="http://mrpeak.cn/blog/thread-sanitizer/" target="_blank" rel="external">十、如何用Xcode8解决多线程问题</a></h3><p>data race：当至少有两个线程同时访问同一个变量，而且至少其中有一个是写操作时，就发生了data race。</p>
<p>常见场景</p>
<ul>
<li><p>场景一：计算出错</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">__block int count = 0;</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    for (int i = 0; i &lt; 10000; i ++) &#123;</div><div class="line">        count ++;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">for (int i = 0; i &lt; 10000; i ++) &#123;</div><div class="line">    count ++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>场景二：Crash！</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NSMutableString* str = [@&quot;&quot; mutableCopy];</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    for (int i = 0; i &lt; 10000; i ++) &#123;</div><div class="line">        [str setString:@&quot;1234567890&quot;];</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">for (int i = 0; i &lt; 10000; i ++) &#123;</div><div class="line">    [str setString:@&quot;abcdefghigk&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>一般会出现在对于复杂对象（class或者struct）的多线程写操作中，原因是因为写操作本身不是原子的，而且写操作背后会调用更多的内存操作，多线程同时写时，会导致这块内存区间处于中间的不稳定状态，进而crash，这是真正的恶性的data race。</p>
<ul>
<li><p>场景三：乱序</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//thread 1</div><div class="line">count = 10;</div><div class="line">countFinished = true;</div><div class="line">//thread 2</div><div class="line">while (countFinished == false) &#123;</div><div class="line">    usleep(1000);</div><div class="line">&#125;</div><div class="line">NSLog(@&quot;count: %d&quot;, count);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>公共变量线程同步。error</p>
<p>编译器并不知道thread 2对count和countFinished这两个变量的赋值顺序有依赖，所以基于优化的目的，有可能会调整thread 1中count = 10;和countFinished = true;生成的最后指令的执行顺序，最后也就导致count值输出的时机不对，虽然最后count的值还是10。这也可以看做是一种benign race，因为也不会crash，而是程序的流程出错。</p>
<blockquote>
<p>遇到这种多线程读写状态，而且存在顺序依赖的场景，不能简单依赖代码逻辑。<strong>解决这种data race场景有一个简单办法：加锁</strong>，比如使用NSLock，<strong>将对顺序有依赖的代码块整个原子化</strong>，加锁之所以有用是因为会生成memory barrier，从而避免了编译器优化。</p>
</blockquote>
<ul>
<li><p>场景四：内存泄漏（存在静态变量的时候）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Singleton *getSingleton() &#123;</div><div class="line">    static Singleton *sharedInstance = nil;</div><div class="line">    if (sharedInstance == nil) &#123;</div><div class="line">        sharedInstance = [[Singleton alloc] init];</div><div class="line">    &#125;</div><div class="line">    return sharedInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>多线程环境下，thread A和thread B会同时进入sharedInstance = [[Singleton alloc] init];，Singleton被多创建了一次，MRC环境就产生了内存泄漏。</p>
<blockquote>
<p>顶层的还是不够牢固。哎！恶补</p>
</blockquote>
<h3 id="十一、iOS多线程到底不安全在哪里？"><a href="#十一、iOS多线程到底不安全在哪里？" class="headerlink" title="十一、iOS多线程到底不安全在哪里？"></a><a href="http://www.mrpeak.cn/blog/ios-thread-safety/" target="_blank" rel="external">十一、iOS多线程到底不安全在哪里？</a></h3><ul>
<li><code>self.userName = @&quot;123&quot;;</code> 是在对指针本身进行赋值</li>
<li><code>[self.userName rangeOfString:@&quot;123&quot;];</code>是在访问指针指向的字符串所在的内存区域，这二者并不一样</li>
</ul>
<p>属性类型。基本类型、指针类型<br><img src="http://www.mrpeak.cn/images/safe00.png" alt=""></p>
<p>至始至终只有三种：<strong>1.值类型Property、2.指针Property、3.指针Property指向的内存区域（这一类多线程的访问场景是我们很容易出错的地方）</strong></p>
<blockquote>
<p>atomic的作用只是给getter和setter加了个锁，atomic只能保证代码进入getter或者setter函数内部时是安全的，一旦出了getter和setter，多线程安全只能靠程序员自己保障了。所以atomic属性和使用property的多线程安全并没什么直接的联系。另外，atomic由于加锁也会带来一些性能损耗，所以我们在编写iOS代码的时候，一般声明property为nonatomic，在需要做多线程安全的场景，自己去额外加锁做同步。</p>
</blockquote>
<p>多线程安全的时候，其实是在讨论多个线程同时访问一个内存区域的安全问题。针对同一块区域，我们有两种操作，读（load）和写（store），读和写同时发生在同一块区域的时候，就有可能出现多线程不安全。</p>
<p>多线程是如何同时访问内存的。不考虑CPU cache对变量的缓存，内存访问可以用下图表示：<br><img src="http://www.mrpeak.cn/images/safe02.png" alt=""><br>只有一个地址总线，一个内存。<strong>即使是在多线程的环境下，也不可能存在两个线程同时访问同一块内存区域的场景，内存的访问一定是通过一个地址总线串行排队访问的</strong></p>
<ul>
<li><p>结论一：内存的访问时串行的，并不会导致内存数据的错乱或者应用的crash。</p>
</li>
<li><p>结论二：如果读写（load or store）的内存长度小于等于地址总线的长度，那么读写的操作是原子的，一次完成。比如bool，int，long在64位系统下的单次读写都是原子操作。</p>
</li>
</ul>
<p>atomic作用：</p>
<ul>
<li>用处一： 生成原子操作的getter和setter。设置atomic之后，默认生成的getter和setter方法执行是原子的。<strong>也就是说，当我们在线程1执行getter方法的时候（创建调用栈，返回地址，出栈），线程B如果想执行setter方法，必须先等getter方法完成才能执行。</strong>举个例子，在32位系统里，如果通过getter返回64位的double，地址总线宽度为32位，从内存当中读取double的时候无法通过原子操作完成，如果不通过atomic加锁，有可能会在读取的中途在其他线程发生setter操作，从而出现异常值。如果出现这种异常值，就发生了多线程不安全。</li>
<li>用处二：设置Memory Barrier。对于Objective C的实现来说，几乎所有的加锁操作最后都会设置memory barrier，atomic本质上是对getter，setter加了锁，所以也会设置memory barrier。<strong>memory barrier能够保证内存操作的顺序，按照我们代码的书写顺序来。听起来有点不可思议，事实是编译器会对我们的代码做优化，在它认为合理的场景改变我们代码最终翻译成的机器指令顺序。</strong></li>
</ul>
<p>问题代码:值类型Property</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@property (atomic, assign)    int       intA;</div><div class="line"></div><div class="line">//thread A</div><div class="line">for (int i = 0; i &lt; 10000; i ++) &#123;</div><div class="line">    self.intA = self.intA + 1;</div><div class="line">    NSLog(@&quot;Thread A: %d\n&quot;, self.intA);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//thread B</div><div class="line">for (int i = 0; i &lt; 10000; i ++) &#123;</div><div class="line">    self.intA = self.intA + 1;</div><div class="line">    NSLog(@&quot;Thread B: %d\n&quot;, self.intA);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即使我将intA声明为atomic，最后的结果也不一定会是20000。<strong>原因就是因为self.intA = self.intA + 1;不是原子操作，虽然intA的getter和setter是原子操作，但当我们使用intA的时候，整个语句并不是原子的，这行赋值的代码至少包含读取(load)，+1(add)，赋值(store)三步操作</strong>，当前线程store的时候可能其他线程已经执行了若干次store了，导致最后的值小于预期值。</p>
<p>问题代码：指针Property</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@property (atomic, strong) NSString*                 userName;</div><div class="line"></div><div class="line">- (void)setUserName:(NSString *)userName &#123;</div><div class="line">    if(_uesrName != userName) &#123;</div><div class="line">        [userName retain];</div><div class="line">        [_userName release];</div><div class="line">        _userName = userName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果property为nonatomic，上述的setter方法就不是原子操作，我们可以假设一种场景，线程1先通过getter获取当前_userName，之后线程2通过setter调用[_userName release];，线程1所持有的_userName就变成无效的地址空间了，如果再给这个地址空间发消息就会导致crash，出现多线程不安全的场景。</p>
<p>问题代码：指针Property指向的内存区域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@property (atomic, strong) NSString*                 stringA;</div><div class="line"></div><div class="line">//thread A</div><div class="line">for (int i = 0; i &lt; 100000; i ++) &#123;</div><div class="line">    if (i % 2 == 0) &#123;</div><div class="line">        self.stringA = @&quot;a very long string&quot;;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        self.stringA = @&quot;string&quot;;</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;Thread A: %@\n&quot;, self.stringA);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//thread B</div><div class="line">for (int i = 0; i &lt; 100000; i ++) &#123;</div><div class="line">    if (self.stringA.length &gt;= 10) &#123;</div><div class="line">        NSString* subStr = [self.stringA substringWithRange:NSMakeRange(0, 10)];</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;Thread B: %@\n&quot;, self.stringA);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然stringA是atomic的property，而且在取substring的时候做了length判断，线程B还是很容易crash，因为在前一刻读length的时候self.stringA = @”a very long string”;，下一刻取substring的时候线程A已经将self.stringA = @”string”;，立即出现out of bounds的Exception，crash，多线程不安全。</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ReadNotes </tag>
            
            <tag> Technology </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络复习]]></title>
      <url>http://yoursite.com/2017/04/05/2017/4/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>　网络这块，平时用得比较多，但接触到原理的机会很少，今天在看一篇文章的时候，提到了网络自定义协议地址<a href="http://mrpeak.cn/blog/tcp-rpc-protocol/" target="_blank" rel="external">如何设计一个通讯协议</a>，顺便就把网络这块一起复习一下。虽然之前也复习过，知识嘛！温故而知新。<br><a id="more"></a></p>
<h2 id="解释图"><a href="#解释图" class="headerlink" title="解释图"></a>解释图</h2><ul>
<li><p>七层模型（讲得比较详细的一张图）<br><img src="http://img.blog.csdn.net/20140924202143732?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFpZ29vY24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
</li>
<li><p>上图的补充说明<br><img src="http://up.2cto.com/2013/0731/20130731095736383.png" alt=""></p>
</li>
</ul>
<h3 id="七层形象比喻"><a href="#七层形象比喻" class="headerlink" title="七层形象比喻"></a>七层形象比喻</h3><p><img src="http://images2015.cnblogs.com/blog/705728/201604/705728-20160424234824085-667046040.png" alt=""></p>
<p><strong>整个过程以公司A和公司B的一次商业报价单发送为例子进行讲解。</strong></p>
<ul>
<li>1、应用层</li>
</ul>
<p>OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。</p>
<blockquote>
<p><strong>实际公司A的老板就是我们所述的用户，而他要发送的商业报价单，就是应用层提供的一种网络服务，当然，老板也可以选择其他服务，比如说，发一份商业合同，发一份询价单，等等。</strong></p>
</blockquote>
<ul>
<li>2、表示层</li>
</ul>
<p>表示层提供各种用于应用层数据的编码和转换功能,<strong>确保一个系统的应用层发送的数据能被另一个系统的应用层识别</strong>。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p>
<blockquote>
<p><strong>由于公司A和公司B是不同国家的公司，他们之间的商定统一用英语作为交流的语言，所以此时表示层（公司的文秘），就是将应用层的传递信息转翻译成英语。同时为了防止别的公司看到，公司A的人也会对这份报价单做一些加密的处理。这就是表示的作用，将应用层的数据转换翻译等。</strong></p>
</blockquote>
<ul>
<li>3、会话层</li>
</ul>
<p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。      </p>
<blockquote>
<p><strong>会话层的同事拿到表示层的同事转换后资料，（会话层的同事类似公司的外联部），会话层的同事那里可能会掌握本公司与其他好多公司的联系方式，这里公司就是实际传递过程中的实体。他们要管理本公司与外界好多公司的联系会话。当接收到表示层的数据后，会话层将会建立并记录本次会话，他首先要找到公司B的地址信息，然后将整份资料放进信封，并写上地址和联系方式。准备将资料寄出。等到确定公司B接收到此份报价单后，此次会话就算结束了，外联部的同事就会终止此次会话。</strong></p>
</blockquote>
<ul>
<li>4、传输层</li>
</ul>
<p>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。</p>
<blockquote>
<p><strong>传输层就相当于公司中的负责快递邮件收发的人，公司自己的投递员，他们负责将上一层的要寄出的资料投递到快递公司或邮局。</strong></p>
</blockquote>
<ul>
<li>5、网络层</li>
</ul>
<p>本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</p>
<blockquote>
<p><strong>网络层就相当于快递公司庞大的快递网络，全国不同的集散中心，比如说，从深圳发往北京的顺丰快递（陆运为例啊，空运好像直接就飞到北京了），首先要到顺丰的深圳集散中心，从深圳集散中心再送到武汉集散中心，从武汉集散中心再寄到北京顺义集散中心。这个每个集散中心，就相当于网络中的一个IP节点。</strong></p>
</blockquote>
<ul>
<li>6、数据链路层 </li>
</ul>
<p>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。</p>
<p>数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。</p>
<blockquote>
<p>MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。</p>
</blockquote>
<ul>
<li>7、物理层     </li>
</ul>
<p>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p>
<blockquote>
<p><strong>快递寄送过程中的交通工具，就相当于我们的物理层，例如汽车，火车，飞机，船。</strong></p>
</blockquote>
<h3 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h3><ul>
<li>七层与五层的关系</li>
</ul>
<p><img src="http://images2015.cnblogs.com/blog/705728/201604/705728-20160424234825491-384470376.png" alt=""></p>
<ul>
<li>对应协议及硬件<br><img src="http://images2015.cnblogs.com/blog/705728/201604/705728-20160424234827195-1493107425.png" alt=""><br><img src="http://images2015.cnblogs.com/blog/705728/201604/705728-20160424234826351-1957282396.png" alt=""></li>
</ul>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p><img src="http://upload-images.jianshu.io/upload_images/3346554-0f81660c9f0659c8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a>Http状态码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">200 OK 客户端请求成功</div><div class="line">301 Moved Permanently 请求永久重定向</div><div class="line">302 Moved Temporarily 请求临时重定向</div><div class="line">304 Not Modified 文件未修改，可以直接使用缓存的文件。</div><div class="line">400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。</div><div class="line">401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用</div><div class="line">403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</div><div class="line">404 Not Found 请求的资源不存在，例如，输入了错误的URL</div><div class="line">500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。</div><div class="line">503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</div></pre></td></tr></table></figure>
<p>在Internet中所有的传输都是通过TCP/IP进行的。HTTP协议作为TCP/IP模型中应用层的协议也不例外。HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。<br><img src="http://images.cnitblog.com/i/116165/201407/111703047392802.png" alt=""></p>
<p><strong>HTTP默认的端口号为80，HTTPS的端口号为443。</strong></p>
<h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p>HTTP定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而 HTTP 中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。</p>
<h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><ul>
<li><p>无状态：HTTP协议是无状态协议。<strong>无状态是指协议对于事务处理没有记忆能力。</strong>缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大</p>
</li>
<li><p>HTTP协议是无状态的和Connection: keep-alive的区别：</p>
<ul>
<li>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。<br>HTTP是一个无状态的面向连接的协议，<strong>无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。</strong></li>
<li>从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</li>
<li>Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</li>
</ul>
</li>
</ul>
<h4 id="请求信息"><a href="#请求信息" class="headerlink" title="请求信息"></a>请求信息</h4><p>三个部分分别是：<strong>请求行、消息报头（请求头）、请求正文。</strong></p>
<ul>
<li>请求行，例如GET /images/logo.gif HTTP/1.1，表示从/images目录下请求logo.gif这个文件。</li>
<li>请求头，例如Accept-Language: en</li>
<li>空行</li>
<li>可选的消息体　请求行和标题必须以<cr><lf>作为结尾（也就是，回车然后换行）。空行内必须只有<cr><lf>而无其他空格。在HTTP/1.1协议中，所有的请求头，除post外，都是可选的。</lf></cr></lf></cr></li>
</ul>
<p><img src="http://images.cnitblog.com/i/116165/201407/121712545823346.png" alt=""></p>
<ul>
<li>GET和POST的区别：<ul>
<li>1、GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中。</li>
<li>2、GET提交的数据大小有限制，最多只能有1024字节（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。</li>
<li>3、GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</li>
<li>4、GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</li>
</ul>
</li>
</ul>
<h4 id="响应消息"><a href="#响应消息" class="headerlink" title="响应消息"></a>响应消息</h4><p>三个部分分别是：<strong>状态行、消息报头、响应正文。</strong><br><img src="http://images.cnitblog.com/i/116165/201407/121720098646366.png" alt=""></p>
<p><img src="http://images.cnitblog.com/i/116165/201407/111156110203396.png" alt=""></p>
<p><img src="http://images.cnitblog.com/i/116165/201407/121724042548791.png" alt=""></p>
<h4 id="解决HTTP无状态的问题"><a href="#解决HTTP无状态的问题" class="headerlink" title="解决HTTP无状态的问题"></a>解决HTTP无状态的问题</h4><ul>
<li><p>通过Cookies保存状态信息</p>
<p><img src="http://images.cnitblog.com/i/116165/201407/122123269892896.png" alt=""></p>
</li>
<li>通过Session保存状态信息</li>
<li>URL重写（通过QueryString保持状态）：URL(统一资源定位符)是Web上特定页面的地址，URL重写的技术就是在URL结尾添加一个附加数据以标识该会话,把会话ID通过URL的信息传递过去，以便在服务器端进行识别不同的用户。</li>
<li>隐藏表单域：将会话ID添加到HTML表单元素中提交到服务器，此表单元素并不在客户端显示</li>
</ul>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>三次握手与四次握手</p>
<p><img src="http://swiftlet.net/wp-content/themes/swiftlet/page-images/tcp/tcp.jpg" alt=""></p>
<p>断开连接端可以是Client端，也可以是Server端。</p>
<ul>
<li>1.假设Client端发起中断连接请求，就先发送FIN报文。<ul>
<li>1.2.Server端接到FIN报文后，但是如果还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以服务器端先发送ACK，告诉Client端：请求已经收到了，但是我还没准备好，请继续等待停止的消息。</li>
</ul>
</li>
<li>2.这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。</li>
<li>3.当Server端确定数据已发送完成，则向Client端发送FIN报文，告诉Client端：服务器这边数据发完了，准备好关闭连接了。</li>
<li>4.Client端收到FIN报文后，就知道可以关闭连接了，但是他还是不相信网络，所以发送ACK后进入TIME_WAIT状态， Server端收到ACK后，就知道可以断开连接了。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，最后，Client端也可以关闭连接了至此，TCP连接就已经完全关闭了！关闭连接的过程如下图所示：</li>
</ul>
<p><img src="http://swiftlet.net/wp-content/themes/swiftlet/page-images/tcp/duankai.jpg" alt=""></p>
<h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><p>SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p>
<ul>
<li><p>如何防御 SYN 攻击？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> 缩短超时（SYN Timeout）时间</div><div class="line">增加最大半连接数</div><div class="line">过滤网关防护</div><div class="line">SYN cookies技术</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>IP地址分类</p>
<table>
<thead>
<tr>
<th style="text-align:center">IP class</th>
<th style="text-align:center">From</th>
<th style="text-align:center">To</th>
<th style="text-align:center">Subnet Mask</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">1.0.0.0</td>
<td style="text-align:center">126.255.255.255</td>
<td style="text-align:center">255.0.0.0</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">128.0.0.0</td>
<td style="text-align:center">191.255.255.255</td>
<td style="text-align:center">255.255.0.0</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">192.0.0.0</td>
<td style="text-align:center">223.255.255.255</td>
<td style="text-align:center">255.255.255.0</td>
</tr>
</tbody>
</table>
<blockquote>
<p>每个IP地址的32位分为前后两部分，<strong>第一部分用来区分局域网，第二个部分用来区分该局域网的主机。</strong>子网掩码(Subnet Mask)告诉我们这两部分的分界线，比如255.0.0.0(也就是8个1和24个0)表示前8位用于区分局域网，后24位用于区分主机。由于A、B、C分类是已经规定好的，所以当一个IP地址属于B类范围时，我们就知道它的前16位和后16位分别表示局域网和主机。</p>
</blockquote>
<p>IP地址实际上识别的是网卡(NIC, Network Interface Card)。网卡是计算机的一个硬件，它在接收到网路信息之后，将信息交给计算机(处理器/内存)。当计算机需要发送信息的时候，也要通过网卡发送。一台计算机可以有不只一个网卡，比如笔记本就有一个以太网卡和一个WiFi网卡。计算机在接收或者发送信息的时候，要先决定想要通过哪个网卡。</p>
<h2 id="Soket"><a href="#Soket" class="headerlink" title="Soket"></a>Soket</h2><blockquote>
<p>Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Socket 起源于 Unix ，Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开(open) –&gt; 读写(write/read) –&gt; 关闭(close)”模式来进行操作。因此 Socket 也被处理为一种特殊的文件。</div></pre></td></tr></table></figure>
<p>之前写过一篇关于Soket相关的文章。这里就不在重复了。<a href="http://www.jianshu.com/p/c7a5fd48dcd6" target="_blank" rel="external">Soket复习</a></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><p>七层模型</p>
<ul>
<li><p><a href="http://www.cnblogs.com/qishui/p/5428938.html" target="_blank" rel="external">OSI七层模型与TCP/IP五层模型</a></p>
</li>
<li><p><a href="http://blog.csdn.net/yaopeng_2005/article/details/7064869" target="_blank" rel="external">OSI七层模型详解</a></p>
</li>
</ul>
</li>
<li><p>HTTP</p>
<ul>
<li><p><a href="http://www.cnblogs.com/EricaMIN1987_IT/p/3837436.html" target="_blank" rel="external">HTTP协议详解</a></p>
</li>
<li><p><a href="https://hit-alibaba.github.io/interview/basic/network/HTTP.html" target="_blank" rel="external">HTTP的特性</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="external">HTTP 协议入门</a></p>
</li>
<li><p><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386832653051fd44e44e4f9e4ed08f3e5a5ab550358d000" target="_blank" rel="external">HTTP协议简介</a></p>
</li>
</ul>
</li>
<li><p>IP</p>
<ul>
<li><a href="http://www.cnblogs.com/vamei/archive/2012/11/30/2794917.html" target="_blank" rel="external">IP接力赛 (IP, ARP, RIP和BGP协议)</a></li>
<li><a href="http://www.cnblogs.com/vamei/archive/2012/12/02/2796988.html" target="_blank" rel="external">IP协议详解</a></li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Recover </category>
            
        </categories>
        
        
        <tags>
            
            <tag> net </tag>
            
            <tag> computer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Andriod SDK Version及API Level]]></title>
      <url>http://yoursite.com/2017/04/01/2017/3/AndroidSDKVersion%E7%AE%80%E4%BB%8B%E5%8F%8A%E9%99%8D%E4%BD%8EAPILevel/</url>
      <content type="html"><![CDATA[<p>　抽空打开了Android Studio准备研究一下开源项目代码，没想到运行不了。总的来说还是自己对Android开发不是太熟，这里简单总结一下遇到的一些坑！<br><a id="more"></a></p>
<h2 id="SDK-Version简单介绍"><a href="#SDK-Version简单介绍" class="headerlink" title="SDK Version简单介绍"></a>SDK Version简单介绍</h2><p>一切源于向前兼容，用户在升级到新版 Android 的时候，用以前版本的 SDK 构建的应用不会出问题。这就是 compileSdkVersion, minSdkVersion 和 targetSdkVersion 的作用：他们分别控制可以使用哪些 API ，要求的 API 级别是什么，以及应用的兼容模式。</p>
<h3 id="Compile-Sdk-Version"><a href="#Compile-Sdk-Version" class="headerlink" title="Compile Sdk Version"></a>Compile Sdk Version</h3><p>compileSdkVersion 告诉 Gradle 用哪个 Android SDK 版本编译你的应用。使用任何新添加的 API 就需要使用对应 Level 的 Android SDK。</p>
<p>修改 compileSdkVersion 不会改变运行时的行为。当你修改了 compileSdkVersion 的时候，可能会出现新的编译警告、编译错误，但新的 compileSdkVersion 不会被包含到 APK 中：它纯粹只是在编译的时候使用。</p>
<p>在开发中最常见的就是总是使用最新的 SDK 进行编译。在现有代码上使用新的编译检查可以获得很多好处，避免新弃用的 API ，并且为使用新的 API 做好准备。Android Stuido默认是用最新的，所以一般不怎么改compileSdkVersion。</p>
<h3 id="Min-Sdk-Version"><a href="#Min-Sdk-Version" class="headerlink" title="Min Sdk Version"></a>Min Sdk Version</h3><p>如果 compileSdkVersion 设置为可用的最新 API，那么 minSdkVersion 则是应用可以运行的最低要求。minSdkVersion 是 Google Play 商店用来判断用户设备是否可以安装某个应用的标志之一。</p>
<p>在开发时 minSdkVersion 也起到一个重要角色：lint 默认会在项目中运行，<strong>它在你使用了高于 minSdkVersion  的 API 时会警告你，帮你避免调用不存在的 API 的运行时问题。</strong>如果只在较高版本的系统上才使用某些 API，通常使用运行时检查系统版本的方式解决。</p>
<p><strong>注意：当使用第三方库可能有他们自己的 minSdkVersion 。你的应用设置的 minSdkVersion 必需大于等于这些库的 minSdkVersion 。</strong></p>
<h3 id="Target-Sdk-Version"><a href="#Target-Sdk-Version" class="headerlink" title="Target Sdk Version"></a>Target Sdk Version</h3><p>targetSdkVersion 是 Android 提供向前兼容的主要依据，在应用的 targetSdkVersion 没有更新之前系统不会应用最新的API变化。这允许你在适应新的API变化之前就可以使用新的 API。</p>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>三者需要满足<code>minSdkVersion &lt;= targetSdkVersion &lt;= compileSdkVersion</code>。但是最为理想的状态应该是<code>minSdkVersion (lowest possible) &lt;=  targetSdkVersion == compileSdkVersion (latest SDK)</code>用较低的 minSdkVersion 来覆盖最大的人群，用最新的 SDK 设置 target 和 compile 来获得最好的外观和行为。</p>
<h2 id="API-Level-与-Version"><a href="#API-Level-与-Version" class="headerlink" title="API Level  与 Version"></a>API Level  与 Version</h2><p>有了上面的基础知识，于是为了学习更为牛逼的代码，于是去GitHub上下载了几个项目的源码。一切都没问题，在连上真机的时候突然报错。提示：<img src="http://upload-images.jianshu.io/upload_images/664334-3cdba0423c0ef161.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">。</p>
<p>于是瞎捣鼓了一下才明白，原来每一个Android版本对应一个API  level。报错的原因就是真机的系统版本低于项目设定的版本。</p>
<p>在官网上找到了一张图标，能够彻底说明这个问题。<a href="http://source.android.com/source/build-numbers.html" target="_blank" rel="external">Codenames, Tags, and Build Numbers</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/664334-c290eec12f54f4af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="降低API-Level"><a href="#降低API-Level" class="headerlink" title="降低API Level"></a>降低API Level</h3><p>为了让项目在真机上运行起来，不得不降低项目的API level。<strong>虽然我这里报错是minSDK,但我这里演示的是所有更改所有sdk，比如comiple,target,misdk的情况。具体更改根据报错信息修改对应的选项即可。</strong></p>
<p>这里有两种方式解决。</p>
<ol>
<li>图形化操作<ul>
<li>1.1 修改 compile Sdk Version<br>  <img src="http://upload-images.jianshu.io/upload_images/664334-7cb1d57138e8cf19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>1.2 修改Target Sdk Version<br>  <img src="http://upload-images.jianshu.io/upload_images/664334-f3332ccd2e6ba093.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>1.3修改完之后，IDE会自动修改build.grade的内容。<br>  <img src="http://upload-images.jianshu.io/upload_images/664334-bcb9adf7bab225fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
</li>
</ol>
<ol>
<li>修改build.gradle：上面提到的这些sdk内容，全部在build.gradle文件里找到。我们可以直接修改相应的内容即可。比如：<br> <img src="http://upload-images.jianshu.io/upload_images/664334-3cd0cfd5755f9a5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>由较高的API Level转至较低的API Level，有时候会出现兼容上的问题。比如较低版本的API Level不支持某些特性。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="https://medium.com/google-developers/picking-your-compilesdkversion-minsdkversion-targetsdkversion-a098a0341ebd" target="_blank" rel="external">Picking your compileSdkVersion, minSdkVersion, and targetSdkVersion</a></p>
<p><a href="http://chinagdg.org/2016/01/picking-your-compilesdkversion-minsdkversion-targetsdkversion/" target="_blank" rel="external">如何选择 compileSdkVersion, minSdkVersion 和 targetSdkVersion</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> SDK </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Blog重头开始]]></title>
      <url>http://yoursite.com/2017/03/31/2017/3/Blog%E9%87%8D%E5%A4%B4%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<p>　自从上次博客从hexo+github迁移到简书后，再也没有捣鼓相关的内容了。今天无意中看到了hexo的主题<a href="https://material.viosey.com/" target="_blank" rel="external">Material Theme</a>，再次燃起兴趣……<br><a id="more"></a></p>
<h2 id="重头开始"><a href="#重头开始" class="headerlink" title="重头开始"></a>重头开始</h2><p>这里完全重头搭建一个gitpage+Hexo的静态博客。所以看完这篇文章之后，你完全可以自己弄一个玩一玩。虽然这些内容完全可以通过官网全部找到，这里也就相当于一个总结吧！</p>
<h2 id="一切源头"><a href="#一切源头" class="headerlink" title="一切源头"></a>一切源头</h2><p><a href="https://github.com/" target="_blank" rel="external">GitHub</a></p>
<ul>
<li>Node.js<ul>
<li><a href="https://github.com/nodejs/node" target="_blank" rel="external">Node.js GitHub地址</a></li>
<li><a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js 文档</a></li>
</ul>
</li>
<li>Hexo<ul>
<li><a href="https://github.com/hexojs/hexo" target="_blank" rel="external">Hexo GitHub 地址</a></li>
<li><a href="https://hexo.io/" target="_blank" rel="external">Hexo 文档</a></li>
<li><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo 中文文档</a></li>
</ul>
</li>
<li>Git<ul>
<li><a href="https://github.com/git/git" target="_blank" rel="external">Git GitHub 地址</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">Git 使用教程- 这里推荐中版</a></li>
</ul>
</li>
<li>Hexo Theme<ul>
<li><a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="external">hexo-theme-material GitHub 地址</a></li>
<li><a href="https://material.viosey.com/" target="_blank" rel="external">material 主题文档</a></li>
</ul>
</li>
</ul>
<p>一下操作步骤，其实在上面的文档中能够全部找到。目前网上流传所谓的教程其实最开始也是从这些官方文档获得的。<strong>所以如果时间充裕，最好从官方文档入手！</strong></p>
<h2 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h2><p>直接打开官方地址<a href="https://nodejs.org/en/" target="_blank" rel="external">node</a>，下载安装包即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/664334-450f0bf96d56c348.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="解决国内NPM慢"><a href="#解决国内NPM慢" class="headerlink" title="解决国内NPM慢"></a>解决国内NPM慢</h3><p><a href="http://blog.csdn.net/rongbo_j/article/details/52106580" target="_blank" rel="external">解决国内NPM安装依赖速度慢问题</a></p>
<p>只生效一次：<code>npm install -gd express --registry=http://registry.npm.taobao.org</code><br>永久生效：<code>npm config set registry http://registry.npm.taobao.org</code></p>
<h4 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h4><p>由于npm插件在国外所有很慢，换成cnpm会快很多。详情可以看<a href="http://npm.taobao.org/" target="_blank" rel="external">http://npm.taobao.org/</a></p>
<p>小白请看<a href="http://blog.csdn.net/zhangwenwu2/article/details/52778521" target="_blank" rel="external">npm用法以及更换到淘宝镜像的方法</a></p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>同样打开官方地址<a href="https://hexo.io/" target="_blank" rel="external">hexo</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/664334-7906f95f92b239fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在终端执行其中的命令即可。</p>
<h2 id="登录GitHub创建项目"><a href="#登录GitHub创建项目" class="headerlink" title="登录GitHub创建项目"></a>登录GitHub创建项目</h2><p><img src="http://upload-images.jianshu.io/upload_images/664334-f50d3d356a202614.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>填写项目名，<strong>这里一定要注意项目名称需要用用户名+github.io结尾</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/664334-41acbd8d7acb0b4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>创建完成之后拖到下面会有关于gitpage的介绍。选择个主题再返回就启用了。<br><img src="http://upload-images.jianshu.io/upload_images/664334-6ff6d02ebe0a17ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>接下来的事情就是将Hexo生成的静态页面push到这个仓库中就可以了。然后访问提示的这个链接就可以看到内容。</p>
<h2 id="自动发布到GitHub"><a href="#自动发布到GitHub" class="headerlink" title="自动发布到GitHub"></a>自动发布到GitHub</h2><p>虽然经过上面的不走，勉勉强强能写点东西并且能够发布了。但是还有很多事情需要做，比如：</p>
<ol>
<li>主题的选择，一般情况下hexo的默认主题不会让你满意。</li>
<li>自动部署，每次写了新的文章都用git命令操作一遍，很费时间。</li>
<li>添加一些本地或者google搜索。</li>
<li>支持评论等</li>
<li>……</li>
</ol>
<p>上面的3、4、5在选用三方主题的时候基本上简单配置一下就可以的。所以不难。</p>
<p><strong>自动部署在官方文档中也用说明。<a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="external">自动部署中文版</a></strong></p>
<ul>
<li>安装<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="external"> hexo-deployer-git</a>：<ul>
<li>在当前hexo生成的目录下执行：<code>npm install hexo-deployer-git --save</code></li>
</ul>
</li>
<li><p>配置deploy内容：比如我这样设置的</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line"> type: git</div><div class="line"> repo: git@github.com:****/***.github.io.git</div><div class="line"> branch: master</div></pre></td></tr></table></figure>
<p>这里repo后面的内容可以直接复制你仓库中的地址：<br><img src="http://upload-images.jianshu.io/upload_images/664334-3bc95bffac2f1955.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
</ul>
<h3 id="给github账号添加ssh"><a href="#给github账号添加ssh" class="headerlink" title="给github账号添加ssh"></a>给github账号添加ssh</h3><p>经过上面的过程依然还不能push到仓库，还没设置ssh。如果你执行了<code>hexo  d</code>会报403的错误。</p>
<p>设置Github的用户名和邮箱</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name &quot;你在Github上的昵称&quot;</div><div class="line">git config --global user.email &quot;你在Github上的邮箱&quot;</div></pre></td></tr></table></figure>
<p>这里是全局设置的用户账号，考虑到某些仓库不能用这个账号，可以具体的仓库中使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config user.name &quot;用户名&quot; </div><div class="line">git config user.email &quot;邮箱&quot;</div></pre></td></tr></table></figure>
<p>设置</p>
<h3 id="公钥私钥"><a href="#公钥私钥" class="headerlink" title="公钥私钥"></a>公钥私钥</h3><p>接下来就是生产公钥私钥：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;你在Github上的邮箱&quot;</div><div class="line">// 多账号情况下：（多个git使用）</div><div class="line">ssh-keygen -t rsa -f ~/.ssh/名称 -C &quot;邮箱&quot;</div></pre></td></tr></table></figure>
<ul>
<li>-t 指定密钥类型，默认是 rsa ，可以省略。</li>
<li>-f 指定密钥文件存储文件名。</li>
</ul>
<p>添加密钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-add id_rsa</div></pre></td></tr></table></figure>
<p>执行后，会填写保存两种密钥的文件夹，和passphrase。这里是指的密码尽量简单点，因为后面会在添加私钥的时候用到。<strong>全部可以按enter。然后执行ls来查看生成后的文件。</strong></p>
<ul>
<li>id_rsa和id_rsa.pub分别是私有密钥和公有密钥。</li>
<li>我们指定的文件名就是id_rsa.github，这时~/.ssh目录下会多出id_rsa.github和id_rsa.github.pub两个文件，id_rsa.github里保存的就是我们要使用的key。</li>
</ul>
<h3 id="有多个git账号怎么办（常见问题）"><a href="#有多个git账号怎么办（常见问题）" class="headerlink" title="有多个git账号怎么办（常见问题）"></a>有多个git账号怎么办（常见问题）</h3><ul>
<li>创建：touch ~/.ssh/config</li>
<li><p>添加内容：例如</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">	#gitlab</div><div class="line">Host ****</div><div class="line">HostName ****</div><div class="line">RSAAuthentication yes</div><div class="line">IdentityFile ~./ssh/id_rsa_gitlab</div><div class="line">#github</div><div class="line">Host****</div><div class="line">HostName ****</div><div class="line">RSAAuthentication yes</div><div class="line">User ****</div><div class="line">IdentityFile ~./ssh/github_id_rsa</div><div class="line">#github</div><div class="line">Host github</div><div class="line">HostName github.com</div><div class="line">RSAAuthentication yes</div><div class="line">User 你的登录邮箱</div><div class="line">IdentityFile ~./ssh/github_id_rsa</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="添加公钥到github账号ssh"><a href="#添加公钥到github账号ssh" class="headerlink" title="添加公钥到github账号ssh"></a>添加公钥到github账号ssh</h3><ul>
<li>打开github账号的设置界面</li>
<li>新建一个SSH Key</li>
</ul>
<p>然后将打开公钥文件，把内容粘贴到<br><img src="http://upload-images.jianshu.io/upload_images/664334-cf6211149269298f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>测试是否成功<code>ssh -T git@github.com</code></p>
<p>如果显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure>
<p>输入yes。<br>然后就可以看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hi yourusername! You&apos;ve successfully authenticated, but GitHub does not</div><div class="line">provide shell access.</div></pre></td></tr></table></figure>
<h2 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h2><p>这部分看着文档走就可以了，没什么难度。当然第一次创建一个比较有感觉的博客还是需要花一些时间的。这里我大致弄了一个模板。如果嫌麻烦可以直接用这个项目生成。地址<a href="https://github.com/ZhiJianShuSheng/BlogRecord" target="_blank" rel="external">后期补上</a></p>
<h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h2><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="http://www.jianshu.com/p/0d7038102cd6" target="_blank" rel="external">生成ssh公钥并连接到github</a><br><a href="http://blog.csdn.net/diamont1001/article/details/51822803" target="_blank" rel="external">Mac里添加多个git ssh</a></p>
]]></content>
      
        <categories>
            
            <category> Blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
