<!DOCTYPE html>
<html>
    <head>
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.2.6 -->

    <!-- Title -->
    
    <title>
        
            技术博客阅读笔记iOS篇(一、MRPEAK) | 
        
        纸简书生
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon1.jpeg">
    <link rel="icon" sizes="192x192" href="/img/favicon1.jpeg">
    <link rel="apple-touch-icon" href="/img/favicon1.jpeg">

    <!-- Meta & Info -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#0097A7">
    <meta name="author" content="纸简书生">
    <meta name="description" content="人与人之间的差别在于，一、想得到和想不到，二、想得到且做到的想到但做不到；离开舒适区、自律是方法论。写作，阅读、锻炼、早起、旅行是方法。牢记方法论、价值观，躬行方法，让自己更好！">
    <meta name="keywords" content="纸简书生、iOS、Android、Java">

    <!--iOS -->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-title" content="Title">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="480">

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="纸简书生">

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://yoursite.com">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="技术博客阅读笔记iOS篇(一、MRPEAK) | 纸简书生">
    <meta property="og:description" content="人与人之间的差别在于，一、想得到和想不到，二、想得到且做到的想到但做不到；离开舒适区、自律是方法论。写作，阅读、锻炼、早起、旅行是方法。牢记方法论、价值观，躬行方法，让自己更好！">

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->

    <!-- Import CSS -->
    <link rel="stylesheet" href="/css/material.min.css">
    <link rel="stylesheet" href="/css/style.min.css">
    <!-- Config CSS -->


<!-- Other Styles -->
<style>
    body, html {
        font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    }

    a {
        color: #00838F;
    }

    .mdl-card__media,
    #search-label,
    #search-form-label:after,
    #scheme-Paradox .hot_tags-count,
    #scheme-Paradox .sidebar_archives-count,
    #scheme-Paradox .sidebar-colored .sidebar-header,
    #scheme-Paradox .sidebar-colored .sidebar-badge{
        background-color: #0097A7 !important;
    }

    /* Sidebar User Drop Down Menu Text Color */
    #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
    #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
        color: #0097A7 !important;
    }

    #post_entry-right-info,
    .sidebar-colored .sidebar-nav li:hover > a,
    .sidebar-colored .sidebar-nav li:hover > a i,
    .sidebar-colored .sidebar-nav li > a:hover,
    .sidebar-colored .sidebar-nav li > a:hover i,
    .sidebar-colored .sidebar-nav li > a:focus i,
    .sidebar-colored .sidebar-nav > .open > a,
    .sidebar-colored .sidebar-nav > .open > a:hover,
    .sidebar-colored .sidebar-nav > .open > a:focus,
    #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
        color: #0097A7 !important;
    }

    .toTop {
        background: #757575 !important;
    }

    .material-layout .material-post>.material-nav,
    .material-layout .material-index>.material-nav,
    .material-nav a {
        color: #757575;
    }

    #scheme-Paradox .MD-burger-layer {
        background-color: #757575;
    }

    #scheme-Paradox #post-toc-trigger-btn {
        color: #757575;
    }

    .post-toc a:hover {
        color: #00838F;
        text-decoration: underline;
    }
</style>


<!-- Theme Background Related-->

    <style>
        body{
            background-image: url(/img/bg3.png);
        }
    </style>




<!-- Fade Effect -->

    <style>
        .fade {
            transition: all 800ms linear;
            -webkit-transform: translate3d(0,0,0);
            -moz-transform: translate3d(0,0,0);
            -ms-transform: translate3d(0,0,0);
            -o-transform: translate3d(0,0,0);
            transform: translate3d(0,0,0);
            opacity: 1;
        }

        .fade.out{
            opacity: 0;
        }
    </style>


    <script src="/js/jquery.min.js"></script>

    <link rel="stylesheet" href="/css/highlight/solarized-white.css">

    <!-- UC Browser Compatible-->
    <script>
        var agent = navigator.userAgent.toLowerCase();
        if(agent.indexOf('ucbrowser')>0) {
            document.write('<link rel="stylesheet" href="/css/uc.css">');
            alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
        }
    </script>

    <!-- Custom Head -->
    
</head>


    
        <body id="scheme-Paradox">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->

    <!-- Left aligned menu below button -->
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#博主MRPEAK"><span class="post-toc-number">1.</span> <span class="post-toc-text">博主MRPEAK</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#一、-如何设计一个通讯协议"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">一、 如何设计一个通讯协议</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二、TCP-IP-系列之重新认识-IP-地址"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">二、TCP/IP 系列之重新认识 IP 地址</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#第一种切割方式"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">第一种切割方式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#第二种切割方式CIDR"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">第二种切割方式CIDR</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#三、TCP-IP-系列之-Header-篇"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">三、TCP/IP 系列之 Header 篇</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#四、TCP-IP-系列之初印象"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">四、TCP/IP 系列之初印象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#延迟"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">延迟</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#五、技术文章的阅读姿势🍎"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">五、技术文章的阅读姿势🍎</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#今天的阅读就到这里了-2017-4-5-pm5-22-下次继续更新"><span class="post-toc-number">2.</span> <span class="post-toc-text">今天的阅读就到这里了 2017-4-5  pm5:22  下次继续更新</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#六、闲聊-Hash-算法"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">六、闲聊 Hash 算法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#七、Improving-Immutable-Object-Initialization-in-Objective-C"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">七、Improving Immutable Object Initialization in Objective-C</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#八、危险的UITableView"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">八、危险的UITableView</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#九、iOS当中的Cache设计"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">九、iOS当中的Cache设计 </span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#十、如何用Xcode8解决多线程问题"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">十、如何用Xcode8解决多线程问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#十一、iOS多线程到底不安全在哪里？"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">十一、iOS多线程到底不安全在哪里？</span></a></li></ol></li></ol>

        <!--
        <li class="mdl-menu__item">
            Some Action
        </li>
        -->
    </ul>




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        <!-- Custom Thumbnail -->
        <div class="post_thumbnail-custom mdl-card__media mdl-color-text--grey-50" style="background-image:url(http://upload-images.jianshu.io/upload_images/664334-a8c8ed40224fae08.png)">
    
            <p class="article-headline-p">
                技术博客阅读笔记iOS篇(一、MRPEAK)
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/avatar3.png" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>纸简书生</strong>
        <span>4月 05, 2017</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-link" href="/tags/ReadNotes/">ReadNotes</a></li><li class="mdl-menu__item"><a class="post_tag-link" href="/tags/Technology/">Technology</a>
    </ul>
    

    <!-- Share -->
    <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    
        <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=技术博客阅读笔记iOS篇(一、MRPEAK)&url=http://yoursite.com//2017/04/05/2017/4/技术博客阅读笔记/index.html&pic=&searchPic=false&style=simple" target="_blank">
            <li class="mdl-menu__item">
                分享到微博
            </li>
        </a>
    

    <!-- Share Twitter -->
    

    <!-- Share Facebook -->
    

    <!-- Share Google+ -->
    

    <!-- Share LinkedIn -->
    

    <!-- Share QQ -->
    

    <!-- Share Telegram -->
    
</ul>

</div>

                

                <!-- Post Content -->
                <div id="post-content" class="markdown-Github mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <p>每天阅读那么多的博客，为什么自己对其中优秀的博客做一个笔记方便自己翻阅呢。而且牛逼的博主，其他文章含量金量也很高。虽然看博客不如看技术书籍来的全面、系统，读完之后也有不少的收获。关于泛读和精读，下面有篇文章有相应的介绍……<br><a id="more"></a></p>
<h2 id="博主MRPEAK"><a href="#博主MRPEAK" class="headerlink" title="博主MRPEAK"></a><a href="http://mrpeak.cn/" target="_blank" rel="external">博主MRPEAK</a></h2><p>一下内容大部分是摘自博客原文，如需细致阅读，建议看原文。<br><a href="http://mrpeak.cn/Archives/" target="_blank" rel="external">历史文章合集</a></p>
<h3 id="一、-如何设计一个通讯协议"><a href="#一、-如何设计一个通讯协议" class="headerlink" title="一、 如何设计一个通讯协议"></a><a href="http://mrpeak.cn/blog/tcp-rpc-protocol/" target="_blank" rel="external">一、 如何设计一个通讯协议</a></h3><p>幸好作者提供了项目源码，可以直接看源码<a href="https://github.com/music4kid/TKeyboard" target="_blank" rel="external">TKeyboard</a></p>
<p>google一搜如何设计一个通讯协议，出现了一大片文章。这里摘取比较有代表性的。<br>找到一个牛逼哄哄的网站<a href="http://www.52im.net/" target="_blank" rel="external">即时通信网</a>，做了IM这么久现在才知道有这样好资源。</p>
<p><a href="http://www.52im.net/thread-283-1-1.html" target="_blank" rel="external">理论联系实际：一套典型的IM通信协议设计详解</a><br><a href="http://gcloud.qq.com/forum/topic/56976ee6ceddce8561c9494d" target="_blank" rel="external">如何设计一个RPC系统</a></p>
<p>应用层常见的有三种：文本协议（Http）、二进制协议(ip)、流式XML协议（xmpp）。他们的各自优缺点可以大致总结出来。后文建议<a href="http://www.52im.net/thread-277-1-1.html" target="_blank" rel="external">强列建议将Protobuf作为你的即时通讯应用数据传输格式</a></p>
<p>工作内容主要有：一是数据的序列化，即将我们平时所用的 model 转化为二进制流，其二是定义好包的格式，在通讯框架里做好包的切割，解析，和传递。最后简化调用流程，提供一套简单的类似 http 的双向数据调用 API 即可。</p>
<ul>
<li>基本思路<ol>
<li>第一个序列化的问题好解决，<strong>已有 google 的成熟方案 protobuf 可以使用（感觉业界都推荐用这个，但是之前在iOS端用过，发现了很多坑爹的地方）</strong>，而且还有基于 Objective C 的版本，model 的序列化和反序列化，一个 API 调用即可完成。</li>
<li>第二个问题是包的格式定义。学习 TCP/IP 的意义在这里就能体现了，无论是 TCP 包还是 IP 包，都有自己的包格式定义，而且往往是一个 header 配合一个 payload（类似于 http 的 body）。之所以要有包，是因为二进制流只完成 stream 的传输，并不知道一次数据请求与相应的起始和结束，我们要预先定义好包结构才能做解析。</li>
<li>要能实现包的准确切割，我们需要明确包的长度。所以必须在 header 中留一个字段，表达整个包（header + payload）由多少 bytes 构成，两个字节的长度就可以描述 0~65535 个字节数，具体使用多少个字节就看协议的使用场景了。</li>
<li>因为是 RPC 调用协议，所以包体里必须有调用的名称，即 API name 字段，这个 name 是可变长度，所以也需要将其长度信息加入包体中，原则上，所有可变长度的内容都需记录其精确的长度信息，否则无法做信息的切割。另外，调用方还需要知道包是请求的回应（response）还是另一端的通知（notify），所以我们还需要定义 call type 信息，这种信息一个 8 比特位的枚举量就绰绰有余了，这种固定长度的信息就不需要记录其长度信息了。</li>
<li>一般固定长度的信息我们放在 header 中，可变长度的信息我们则放入 payload 中，当然，我们 RPC 调用的具体参数（经由 protobuf 序列化之后的 stream）也是放入 payload 中，接收方接收以后，只需读取固定长度的字节，即可通过反序列化，再在接收方还原成具体的应用层数据。</li>
</ol>
</li>
</ul>
<p>特别注意：<strong>因为我们是在设计应用层协议，所以还需要考虑传输层是可靠还是不可靠，CoreBlueTooth 实际上既提供了类似于 TCP 的可靠传输（CBCharacteristicPropertyIndicate），也有类似于 UDP 的不可靠传输（CBCharacteristicPropertyNotify），不明白这一点，必然会踩坑</strong></p>
<h3 id="二、TCP-IP-系列之重新认识-IP-地址"><a href="#二、TCP-IP-系列之重新认识-IP-地址" class="headerlink" title="二、TCP/IP 系列之重新认识 IP 地址"></a><a href="http://mrpeak.cn/blog/tcp-ip/" target="_blank" rel="external">二、TCP/IP 系列之重新认识 IP 地址</a></h3><p>大学里面网络基础学过，但是基本上都忘记了。看到这篇突然想起了一些<code>远古</code>的记忆。</p>
<blockquote>
<p>internet 其实是由无数个子网所构成，是一个二级的结构，第一级是子网，第二级才是子网中的设备。所以 internet 中设备 A 的信息要抵达设备 B，必须先要找到 B 所在的子网，进而再在子网中找到 B。</p>
</blockquote>
<p>IP 地址的结构：IP 地址 = 网络地址 + 主机地址。子网掩码（subnet mask） 就是为了分割 Network ID 和 Host ID 的</p>
<h4 id="第一种切割方式"><a href="#第一种切割方式" class="headerlink" title="第一种切割方式"></a>第一种切割方式</h4><ul>
<li>第一个字节为 Network ID，剩下三个字节为 Host ID</li>
<li>第二个字节为 Network ID，剩下两个字节为 Host ID</li>
<li><p>第三个字节为 Network ID，剩下一个字节为 Host ID<br>有问题</p>
</li>
<li><p>我们如何确定一个 IP 地址是属于 A B C 的哪一类呢？我们以第一个字节来做一些约定：</p>
<ol>
<li>如果第一个字节的起始比特位为 0，则是 A 类地址。</li>
<li>如果第一个字节的起始比特位为 10，则是 B 类地址。</li>
<li>如果第一个字节的起始比特位为 110，则是 C 类地址。</li>
</ol>
</li>
</ul>
<h4 id="第二种切割方式CIDR"><a href="#第二种切割方式CIDR" class="headerlink" title="第二种切割方式CIDR"></a>第二种切割方式CIDR</h4><p>全称为 Classless Inter-Domain Routin。CIDR 是新的子网掩码的表达方式和路由方式。这里注意 CIDR 和 CIDR notation 的区别，CIDR notation 是描述 IP 地址如何切割的方式，而 CIDR 描述的是基于 CIDR notation 的路由方式。</p>
<p>CIDR notation 其实概念也很直白，它不再粗暴的以字节为粒度来切分 IP 地址，而是精确到 bit 位，我们看一个典型的 CIDR notation：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">123.121.114.144/23</div></pre></td></tr></table></figure>
<p>注意 IP 地址后面的 /23，这就是 CIDR notation，<strong>它表示 IP 地址的前 23 bits 为 Network ID，剩余的 9 bits 为 Host ID。23 并不是 8 的倍数，我们将切分的精读提高到了 bit。</strong>我们可以通过简单的位运算，得到具体的 Network ID 和 Host ID，我们将 IP 地址和 /23 先转为二进制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">01111011.01111001.01110010.10010000 IP 地址</div><div class="line">11111111.11111111.11111110.00000000 /23 subnet mask</div></pre></td></tr></table></figure>
<p>得到 Network ID 和 Host ID：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">01111011.01111001.01110010.00000000 Network ID</div><div class="line">00000000.00000000.00000000.10010000 Host ID</div></pre></td></tr></table></figure>
<blockquote>
<p>再将二进制转换为十进制，我们就得到了便于理解的 Network ID：123.121.114.0。由于 Host ID 占用 9 个 bits，这个子网里一共可以有 2 的 9 次方个主机数，也就是 512 个主机，这个子网网段的起始地址为 123.121.114.0，结束地址为 123.121.115.255。我们对于某一个网段内的 IP 地址，有个约定，第一个地址为 Network ID，最后一个地址是该子网内的 Broadcast ID，那么剩下的可用于子网内设备的 IP 地址数量就是 510 个了。</p>
</blockquote>
<p>IP 地址虽然只是一个二级的结构，但 IP 地址的分配却是一层一层，经历多层往下分发的，由一个国际机构 IANA 统一分配。具体规则可以参考 IANA 官网：<a href="https://www.iana.org/numbers" target="_blank" rel="external">https://www.iana.org/numbers</a></p>
<p>用户拿到 IP 地址后，所发送包要经过一个个的路由器才能抵达正确的地址。</p>
<h3 id="三、TCP-IP-系列之-Header-篇"><a href="#三、TCP-IP-系列之-Header-篇" class="headerlink" title="三、TCP/IP 系列之 Header 篇"></a><a href="http://mrpeak.cn/blog/tcp-headers/" target="_blank" rel="external">三、TCP/IP 系列之 Header 篇</a></h3><p><img src="http://www.mrpeak.cn/images/ws03.png" alt=""></p>
<p>如果以一个 HTTP 请求为例，右图中 Application 部分就代表我们用 Charles 抓包时所感知的部分，这一部分要最后转化为光信号，在光纤中传输，还需要经过一层层的转化，这个转化过程说白了，就是在每一层加上一个 header。</p>
<ul>
<li>Application 层（HTTP）的数据在经过传输层（TCP Layer）的时候，会加上 TCP 的 header，成为一个 TCP Segment。</li>
<li>传输层（TCP）的 Segment 在经过网络层（IP Layer）的时候，会加上 IP 的 header，成为一个 IP Packet。</li>
<li>网络层的 IP Packet 在经过链路层（Link Layer）的时候，会加上Link Layer 的 header，成为一个 Frame。</li>
<li>最后 Frame 会在物理层，将数字信号转化为物理信号传输。</li>
</ul>
<p>看张图片一切就明了了<br><img src="http://www.mrpeak.cn/images/ws05.png" alt=""></p>
<p>深入研究可以看<a href="http://www.cnblogs.com/zhuimengle/p/5737848.html" target="_blank" rel="external">TCPdump抓包命令详解</a><br><a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html" target="_blank" rel="external">Linux tcpdump命令详解</a></p>
<h3 id="四、TCP-IP-系列之初印象"><a href="#四、TCP-IP-系列之初印象" class="headerlink" title="四、TCP/IP 系列之初印象"></a><a href="http://mrpeak.cn/blog/tcp-preface/" target="_blank" rel="external">四、TCP/IP 系列之初印象</a></h3><p>0 和 1 是计算机世界的基础粒子，大量的 0 和 1 组合在一起就形成了一个流（Stream），客户端向服务器发送数据的时候，说白了就是一堆 0 和 1 的组合。一次完整的 http 会话是建立在一个 TCP 连接之上，这个 TCP 连接的生命周期内所有发送的数据最后可以看做是一个流。<strong>而在这个流里，我们可以按照某种规则把它切割成一个个的包（packet）。</strong>比如 TCP 三次握手里就包含了 SYN，SYN+ACK，ACK 三个包，而这三个包，不过是整个 TCP Stream 最开始的部分数据而已。</p>
<p>所以简单来说，一个 TCP 连接里，是既有流的概念，又有包的存在，有些问题场景下会谈论流，另一些则会说起包，端看具体的场景如何。</p>
<p>客户端和服务器之间有两根管道，一根上行（从客户端到服务器），一根下行（从服务器到客户端），管道里流动着无数的 0 和 1，有时候管道里是满的，有时候管道里则空空如也，每次发送数据，都会有大量的 0 和 1 从一端涌向另一端。</p>
<h4 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h4><p>由两部分组成的，其一是 Transmission Delay，另一个是 Propagation Delay。</p>
<p>Transmission Delay。计算机世界里的 0 和 1， 最后要能在光纤中传输，需要在 Physical Layer 将数字信号转化为物理信号，这个转化也是存在速度瓶颈的，我们用 Rate (bits/seconds) 来描述这个转化的速度，Rate 表示每一秒钟里，硬件设备能将多少 bits 转化为光信号放入光纤中。</p>
<p> Propagation Delay。这才是大部分人所理解的传播延迟，和距离直接相关。</p>
<h3 id="五、技术文章的阅读姿势🍎"><a href="#五、技术文章的阅读姿势🍎" class="headerlink" title="五、技术文章的阅读姿势🍎"></a><a href="http://mrpeak.cn/blog/ios-tech-article/" target="_blank" rel="external">五、技术文章的阅读姿势</a>🍎</h3><p>作者和自己的感想比较相似，关于泛读和精读给出了自己的解释。对于自己而言，确实是这样，总结出来的经验也非常值得自己借鉴。</p>
<p>由于技术的知识体系往往是个树形的结构，单个术语下都有其相关的知识域，可以一层又一层牵扯出更多的子术语。在阅读文章遭遇这种树形结构的时候，要能抑制住自己不停探索的欲望，<strong>对于技术术语的学习只做适度延伸，最终的目的还是在于完成根部文章的阅读。</strong>尽量只做一到两层的延伸。</p>
<p>尽量选择没人打扰的时间段来做阅读，可以是早上刚到公司，或者别人午睡时，总之越安静，越没人找越好。</p>
<blockquote>
<p><strong>对于基础知识的阅读，要重官方文档，切莫心急动手，看完文档形成知识体系后再写代码不迟。</strong>减少泛读行为，避免漫无目的的随意浏览技术文章。注重精读，一天一篇不算少，一周一篇也正常。<strong>重阅读质量而非数量，挑选每天安静且不易被打断的时间点来阅读，尽量多啃原版书。</strong></p>
</blockquote>
<h2 id="今天的阅读就到这里了-2017-4-5-pm5-22-下次继续更新"><a href="#今天的阅读就到这里了-2017-4-5-pm5-22-下次继续更新" class="headerlink" title="今天的阅读就到这里了 2017-4-5  pm5:22  下次继续更新"></a>今天的阅读就到这里了 2017-4-5  pm5:22  下次继续更新</h2><blockquote>
<p>时隔一个多月</p>
</blockquote>
<h3 id="六、闲聊-Hash-算法"><a href="#六、闲聊-Hash-算法" class="headerlink" title="六、闲聊 Hash 算法"></a><a href="http://mrpeak.cn/blog/hash/" target="_blank" rel="external">六、闲聊 Hash 算法</a></h3><blockquote>
<p>数据结构和算法是相辅相成的，基础的其实就那么些：时间复杂度的概念，List，Array，Stack，Queue，Tree 等。Graph 实际应用中较少遇到，可以不做深入了解，但 BFS，DFS，Dijkstra 还是应该知道。基础的算法需要能达到手写的程度，比如排序至少能写出两种时间复杂度为 N*logN 的算法。理解这些比去 leetcode 刷题重要，学习难度也并不高。学习这些的意义在于掌握解决问题的基础思路，形成计算机思维，比如 divide and conque，recursive 等常规思想。</p>
</blockquote>
<h3 id="七、Improving-Immutable-Object-Initialization-in-Objective-C"><a href="#七、Improving-Immutable-Object-Initialization-in-Objective-C" class="headerlink" title="七、Improving Immutable Object Initialization in Objective-C"></a><a href="http://holko.pl/2015/05/12/immutable-object-initialization/" target="_blank" rel="external">七、Improving Immutable Object Initialization in Objective-C</a></h3><ol>
<li>Initializer mapping arguments to properties</li>
<li>Initializer taking dictionary</li>
<li>Mutable subclass</li>
<li>Improving builder pattern</li>
</ol>
<h3 id="八、危险的UITableView"><a href="#八、危险的UITableView" class="headerlink" title="八、危险的UITableView"></a><a href="http://mrpeak.cn/blog/tableview-danger/" target="_blank" rel="external">八、危险的UITableView</a></h3><p>总体来说就是调用了tableView的reloadData方法之后，代理方法有些不是同步执行的。具体来讲。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">当我们reloadData的时候，我们本意是刷新UITableView，随后会进入一系列UITableViewDataSource和UITableViewDelegate的回调，其中有些是和reloadData同步发生的，有些则是异步发生的。</div><div class="line"></div><div class="line">我们熟悉的下面两个回调是同步的：</div><div class="line"></div><div class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">    return 20;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section</div><div class="line">&#123;</div><div class="line">    return _arr.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">而另一个最常使用的回调则是异步的：</div><div class="line"></div><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">   //...</div><div class="line">   NSNumber* content = _arr[indexPath.row];</div><div class="line">   //...</div><div class="line">&#125;</div><div class="line">经过上面的分析，我们不难UITableView的危险之处在于哪了，在于异步执行cellForRowAtIndexPath的时候，我们所依赖的状态可能会发生变化，上面代码中的_arr如果元素被修改过，极有可能发生数组越界的异常。</div></pre></td></tr></table></figure>
<p>优化方案</p>
<p>throttle机制，控制刷新事件的产生频率，建立一个Queue以一定的时间间隔来调用reloadData。事实上这是一种很常见的界面优化机制，对于一些刷新频率可能很高的列表界面，比如微信的会话列表界面，如果很长时间没有登录了，打开App时，堆积了很久的离线消息会在短时间内，导致大量的界面刷新请求，频繁的调用reloadData还会造成界面的卡顿，所以此时建立一个FIFO的Queue，以一定的间隔来刷新界面就很有必要了。</p>
<h3 id="九、iOS当中的Cache设计"><a href="#九、iOS当中的Cache设计" class="headerlink" title="九、iOS当中的Cache设计 "></a><a href="http://mrpeak.cn/blog/ios-cache/" target="_blank" rel="external">九、iOS当中的Cache设计 </a></h3><p>需要看看<a href="https://my.oschina.net/huangyong/blog/177559" target="_blank" rel="external"> 一个简单的 Cache 淘汰策略</a><br>副作用的理解：</p>
<blockquote>
<p>所有对我们整个App有副作用的代码都需要被集中管理，要能从架构的层面去理解和定位。怎么去定义副作用呢？<strong>可以抽象成一种「写操作」，往Cache中添加新的记录就是写操作，这种写操作的副作用是额外的内存开销</strong>，Cache的本质是以空间换时间，这空间损耗就是我们的副作用，一个副作用会引发其他更多的副作用，理清这些副作用往往需要反复查阅大量的代码。更好的办法是，一开始就把有副作用的代码集中管理。</p>
</blockquote>
<ul>
<li>cache的另一个重要知识点是cache的淘汰策略，不同的策略表现也不一样，FIFO，LRU，2Queues等等，现在有不少成熟的第三方cache框架可以使用，系统也提供了淘汰策略不明确的NSCache。</li>
<li><p><strong>cache的使用要有收有放，不能只创建不释放，事实上，所有涉及到data的操作都要考虑data的生命周期。我们做业务的时候，多是以Controller为基础单位，有些场景下，一个Controller在退出之后被再次进入的可能性就非常之低了，适时的清理cache会让我们App的整体表现更好。</strong></p>
</li>
<li><p>只要保证业务模块从Cache中获取的数据都是独立的copy，就能避免数据共享带来的各种隐患。</p>
</li>
</ul>
<p>最后看一下<a href="https://github.com/ibireme/YYCache" target="_blank" rel="external">YYCache</a>加深学习</p>
<h3 id="十、如何用Xcode8解决多线程问题"><a href="#十、如何用Xcode8解决多线程问题" class="headerlink" title="十、如何用Xcode8解决多线程问题"></a><a href="http://mrpeak.cn/blog/thread-sanitizer/" target="_blank" rel="external">十、如何用Xcode8解决多线程问题</a></h3><p>data race：当至少有两个线程同时访问同一个变量，而且至少其中有一个是写操作时，就发生了data race。</p>
<p>常见场景</p>
<ul>
<li><p>场景一：计算出错</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">__block int count = 0;</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    for (int i = 0; i &lt; 10000; i ++) &#123;</div><div class="line">        count ++;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">for (int i = 0; i &lt; 10000; i ++) &#123;</div><div class="line">    count ++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>场景二：Crash！</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NSMutableString* str = [@&quot;&quot; mutableCopy];</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    for (int i = 0; i &lt; 10000; i ++) &#123;</div><div class="line">        [str setString:@&quot;1234567890&quot;];</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">for (int i = 0; i &lt; 10000; i ++) &#123;</div><div class="line">    [str setString:@&quot;abcdefghigk&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>一般会出现在对于复杂对象（class或者struct）的多线程写操作中，原因是因为写操作本身不是原子的，而且写操作背后会调用更多的内存操作，多线程同时写时，会导致这块内存区间处于中间的不稳定状态，进而crash，这是真正的恶性的data race。</p>
<ul>
<li><p>场景三：乱序</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//thread 1</div><div class="line">count = 10;</div><div class="line">countFinished = true;</div><div class="line">//thread 2</div><div class="line">while (countFinished == false) &#123;</div><div class="line">    usleep(1000);</div><div class="line">&#125;</div><div class="line">NSLog(@&quot;count: %d&quot;, count);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>公共变量线程同步。error</p>
<p>编译器并不知道thread 2对count和countFinished这两个变量的赋值顺序有依赖，所以基于优化的目的，有可能会调整thread 1中count = 10;和countFinished = true;生成的最后指令的执行顺序，最后也就导致count值输出的时机不对，虽然最后count的值还是10。这也可以看做是一种benign race，因为也不会crash，而是程序的流程出错。</p>
<blockquote>
<p>遇到这种多线程读写状态，而且存在顺序依赖的场景，不能简单依赖代码逻辑。<strong>解决这种data race场景有一个简单办法：加锁</strong>，比如使用NSLock，<strong>将对顺序有依赖的代码块整个原子化</strong>，加锁之所以有用是因为会生成memory barrier，从而避免了编译器优化。</p>
</blockquote>
<ul>
<li><p>场景四：内存泄漏（存在静态变量的时候）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Singleton *getSingleton() &#123;</div><div class="line">    static Singleton *sharedInstance = nil;</div><div class="line">    if (sharedInstance == nil) &#123;</div><div class="line">        sharedInstance = [[Singleton alloc] init];</div><div class="line">    &#125;</div><div class="line">    return sharedInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>多线程环境下，thread A和thread B会同时进入sharedInstance = [[Singleton alloc] init];，Singleton被多创建了一次，MRC环境就产生了内存泄漏。</p>
<blockquote>
<p>顶层的还是不够牢固。哎！恶补</p>
</blockquote>
<h3 id="十一、iOS多线程到底不安全在哪里？"><a href="#十一、iOS多线程到底不安全在哪里？" class="headerlink" title="十一、iOS多线程到底不安全在哪里？"></a><a href="http://www.mrpeak.cn/blog/ios-thread-safety/" target="_blank" rel="external">十一、iOS多线程到底不安全在哪里？</a></h3><ul>
<li><code>self.userName = @&quot;123&quot;;</code> 是在对指针本身进行赋值</li>
<li><code>[self.userName rangeOfString:@&quot;123&quot;];</code>是在访问指针指向的字符串所在的内存区域，这二者并不一样</li>
</ul>
<p>属性类型。基本类型、指针类型<br><img src="http://www.mrpeak.cn/images/safe00.png" alt=""></p>
<p>至始至终只有三种：<strong>1.值类型Property、2.指针Property、3.指针Property指向的内存区域（这一类多线程的访问场景是我们很容易出错的地方）</strong></p>
<blockquote>
<p>atomic的作用只是给getter和setter加了个锁，atomic只能保证代码进入getter或者setter函数内部时是安全的，一旦出了getter和setter，多线程安全只能靠程序员自己保障了。所以atomic属性和使用property的多线程安全并没什么直接的联系。另外，atomic由于加锁也会带来一些性能损耗，所以我们在编写iOS代码的时候，一般声明property为nonatomic，在需要做多线程安全的场景，自己去额外加锁做同步。</p>
</blockquote>
<p>多线程安全的时候，其实是在讨论多个线程同时访问一个内存区域的安全问题。针对同一块区域，我们有两种操作，读（load）和写（store），读和写同时发生在同一块区域的时候，就有可能出现多线程不安全。</p>
<p>多线程是如何同时访问内存的。不考虑CPU cache对变量的缓存，内存访问可以用下图表示：<br><img src="http://www.mrpeak.cn/images/safe02.png" alt=""><br>只有一个地址总线，一个内存。<strong>即使是在多线程的环境下，也不可能存在两个线程同时访问同一块内存区域的场景，内存的访问一定是通过一个地址总线串行排队访问的</strong></p>
<ul>
<li><p>结论一：内存的访问时串行的，并不会导致内存数据的错乱或者应用的crash。</p>
</li>
<li><p>结论二：如果读写（load or store）的内存长度小于等于地址总线的长度，那么读写的操作是原子的，一次完成。比如bool，int，long在64位系统下的单次读写都是原子操作。</p>
</li>
</ul>
<p>atomic作用：</p>
<ul>
<li>用处一： 生成原子操作的getter和setter。设置atomic之后，默认生成的getter和setter方法执行是原子的。<strong>也就是说，当我们在线程1执行getter方法的时候（创建调用栈，返回地址，出栈），线程B如果想执行setter方法，必须先等getter方法完成才能执行。</strong>举个例子，在32位系统里，如果通过getter返回64位的double，地址总线宽度为32位，从内存当中读取double的时候无法通过原子操作完成，如果不通过atomic加锁，有可能会在读取的中途在其他线程发生setter操作，从而出现异常值。如果出现这种异常值，就发生了多线程不安全。</li>
<li>用处二：设置Memory Barrier。对于Objective C的实现来说，几乎所有的加锁操作最后都会设置memory barrier，atomic本质上是对getter，setter加了锁，所以也会设置memory barrier。<strong>memory barrier能够保证内存操作的顺序，按照我们代码的书写顺序来。听起来有点不可思议，事实是编译器会对我们的代码做优化，在它认为合理的场景改变我们代码最终翻译成的机器指令顺序。</strong></li>
</ul>
<p>问题代码:值类型Property</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@property (atomic, assign)    int       intA;</div><div class="line"></div><div class="line">//thread A</div><div class="line">for (int i = 0; i &lt; 10000; i ++) &#123;</div><div class="line">    self.intA = self.intA + 1;</div><div class="line">    NSLog(@&quot;Thread A: %d\n&quot;, self.intA);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//thread B</div><div class="line">for (int i = 0; i &lt; 10000; i ++) &#123;</div><div class="line">    self.intA = self.intA + 1;</div><div class="line">    NSLog(@&quot;Thread B: %d\n&quot;, self.intA);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即使我将intA声明为atomic，最后的结果也不一定会是20000。<strong>原因就是因为self.intA = self.intA + 1;不是原子操作，虽然intA的getter和setter是原子操作，但当我们使用intA的时候，整个语句并不是原子的，这行赋值的代码至少包含读取(load)，+1(add)，赋值(store)三步操作</strong>，当前线程store的时候可能其他线程已经执行了若干次store了，导致最后的值小于预期值。</p>
<p>问题代码：指针Property</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@property (atomic, strong) NSString*                 userName;</div><div class="line"></div><div class="line">- (void)setUserName:(NSString *)userName &#123;</div><div class="line">    if(_uesrName != userName) &#123;</div><div class="line">        [userName retain];</div><div class="line">        [_userName release];</div><div class="line">        _userName = userName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果property为nonatomic，上述的setter方法就不是原子操作，我们可以假设一种场景，线程1先通过getter获取当前_userName，之后线程2通过setter调用[_userName release];，线程1所持有的_userName就变成无效的地址空间了，如果再给这个地址空间发消息就会导致crash，出现多线程不安全的场景。</p>
<p>问题代码：指针Property指向的内存区域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@property (atomic, strong) NSString*                 stringA;</div><div class="line"></div><div class="line">//thread A</div><div class="line">for (int i = 0; i &lt; 100000; i ++) &#123;</div><div class="line">    if (i % 2 == 0) &#123;</div><div class="line">        self.stringA = @&quot;a very long string&quot;;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        self.stringA = @&quot;string&quot;;</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;Thread A: %@\n&quot;, self.stringA);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//thread B</div><div class="line">for (int i = 0; i &lt; 100000; i ++) &#123;</div><div class="line">    if (self.stringA.length &gt;= 10) &#123;</div><div class="line">        NSString* subStr = [self.stringA substringWithRange:NSMakeRange(0, 10)];</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;Thread B: %@\n&quot;, self.stringA);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然stringA是atomic的property，而且在取substring的时候做了length判断，线程B还是很容易crash，因为在前一刻读length的时候self.stringA = @”a very long string”;，下一刻取substring的时候线程A已经将self.stringA = @”string”;，立即出现out of bounds的Exception，crash，多线程不安全。</p>

    

    
</div>


                

                <!-- Post Comments -->
                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2017/04/05/2017/4/计算机网络复习/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            新篇
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2017/04/05/2017/4/最近遇到的问题/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/avatar3.png" alt="纸简书生's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        weslywxl@gmail.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="#" target="_blank" title="Email Me">
                        <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    <li id="sidebar-first-li">
        <a href="/" target="_self">
            <i class="material-icons sidebar-material-icons">home</i>
            主页
        </a>
    </li>

    <!-- I'm Feeling Lucky -->
    <!--
    <li class="dropdown">
        <a href="" target="_self">
            <i class="material-icons sidebar-material-icons">explore</i>
             sidebar.imlucky
        </a>
    </li>
    -->

    <!-- Archives  -->
    <li class="dropdown">
        <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
            <i class="material-icons sidebar-material-icons">inbox</i>
             归档
            <b class="caret"></b>
        </a>
        <ul class="dropdown-menu">
            <li>
            <a class="sidebar_archives-link" href="/archives/2017/05/">五月 2017<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/04/">四月 2017<span class="sidebar_archives-count">12</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/03/">三月 2017<span class="sidebar_archives-count">1</span></a>
        </ul>
    </li>

    <!-- Categories  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                <i class="material-icons sidebar-material-icons">chrome_reader_mode</i>
                分类
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
                <li>
                <a class="sidebar_archives-link" href="/categories/Android/">Android<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/Blog/">Blog<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/Recover/">Recover<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/iOS/">iOS<span class="sidebar_archives-count">9</span></a></li><li><a class="sidebar_archives-link" href="/categories/iOS/animation/">animation<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/categories/iOS/audio/">audio<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/iOS/base/">base<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/iOS/face-recognize/">face recognize<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/iOS/issue/">issue<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/categories/iOS/recover/">recover<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/language/">language<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/categories/language/base/">base<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/categories/mac/">mac<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/mac/tool/">tool<span class="sidebar_archives-count">1</span></a>
            </ul>
        </li>
    

    <!-- Divider -->
    <li class="divider"></li>


    <!-- Pages  -->
  	

    <!-- Article Numebr  -->
    <li>
        <a href="/archives">
            文章总数
            <span class="sidebar-badge">15</span>
        </a>
    </li>
</ul>


        <!-- Sidebar Divider -->
        <div class="sidebar-divider"></div>

        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Theme Material -->
<a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
    <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
        主题 - Material
        <span class="sidebar-badge badge-circle">i</span>
    </div>
</a>

<!-- Help & Support -->
<!--
<a href="mailto:hiviosey@gmail.com" class="sidebar-footer-text-a">
    <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
    sidebar.help
    <span class="mdl-button__ripple-container">
      <span class="mdl-ripple"></span>
    </span>
  </div>
</a>
-->

<!-- Feedback -->
<!--
<a href="https://github.com/viosey/hexo-theme-material/issues" target="_blank" class="sidebar-footer-text-a">
    <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
         sidebar.feedback
                    <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></div>
</a>
-->

<!-- Abount Theme -->
<!--
<a href="https://blog.viosey.com/index.php/Material.html" target="_blank" class="sidebar-footer-text-a">
    <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
         sidebar.about_theme
        <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></div>
</a>-->

    </div>

    <!-- Sidebar Sponsor -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    

    <!-- Facebook -->
    

    <!-- Google + -->
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©&nbsp;
            <script type="text/javascript">
                var fd = new Date();
                document.write(fd.getFullYear());
            </script>
            &nbsp;纸简书生
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import File -->
<script src="/js/highlight.min.js"></script>
<script src="/js/js.min.js"></script>
<script src="/js/nprogress.js"></script>

<script type="text/javascript">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();

    $('#nprogress .bar').css({
        'background': '#FF4081'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #FF4081, 0 0 15px #FF4081'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#FF4081',
        'border-left-color': '#FF4081'
    });

    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>



    <script src="/js/smoothscroll.js"></script>











<!-- Swiftye -->


<!-- Local Search-->

    <script>
    var searchFunc = function(path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: 'xml',
            success: function( xmlResponse ) {
                // get the contents from search data
                var datas = $( 'entry', xmlResponse ).map(function() {
                    return {
                        title: $( 'title', this ).text(),
                        content: $('content',this).text(),
                        url: $( 'url' , this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function() {
                    var str='<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function(data) {
                        var isMatch = true;
                        var content_index = [];
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                        var data_url = data.url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if(data_title != '' && data_content != '') {
                            keywords.forEach(function(keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if( index_title < 0 && index_content < 0 ) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += '<li><a href="'+ data_url +'" class="search-result-title" target="_blank">'+ data_title;
                            var content = data.content.trim().replace(/<[^>]+>/g, '');
                            if (first_occur >= 0) {
                                // cut out characters
                                var start = first_occur - 6;
                                var end = first_occur + 6;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 10;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function(keyword) {
                                    var regS = new RegExp(keyword, 'gi');
                                    match_content = match_content.replace(regS, '<em class="search-keyword">'+keyword+'</em>');
                                })
                                str += '<p class="search-result">' + match_content +'...</p>' +'</a>';
                            }
                        }
                    });
                    $resultContent.innerHTML = str;
                });
            }
        });
    }
</script>


    <script>
        var inputArea = document.querySelector('#search');
        var getSearchFile = function() {
            var path = 'search.xml';
            searchFunc(path, 'search', 'local-search-result');
        }

        if(inputArea) {
            inputArea.onfocus = function() {
                getSearchFile();
            }
        }
    </script>


<!-- Window Load-->
<script>
    $(window).load(function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });
</script>

<!-- MathJax Load-->


                </main>
            </div>
        </body>
    
</html>
